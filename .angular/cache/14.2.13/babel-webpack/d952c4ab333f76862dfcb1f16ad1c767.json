{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nlet BtmOrchestratorService = class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n   * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n   */\n\n\n  processXml(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err)))); // 2) CSV -> flat JSON tablo (mevcut converter servisi ile)\n        // Varsayılan opsiyonlar, ihtiyaca göre UI'dan alınabilir\n\n        const csvOptions = {\n          hasHeader: true,\n          skipEmptyLines: true,\n          selectedDelimiter: ',',\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        }; // CSV string'i File objesine çeviriyoruz (converter File bekliyor)\n\n        const csvFile = new File([csvString], 'btm-output.csv', {\n          type: 'text/csv'\n        });\n        const {\n          result: rows,\n          properties: headers\n        } = yield _this.csvFileConverter.convert(csvFile, csvOptions); // 3) flat'ten okunaklı/gruplu JSON üret\n\n        const pretty = _this.transformBtmJson(rows);\n\n        return {\n          result: rows,\n          properties: headers,\n          prettyJson: pretty,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 4) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        }); // localResult zaten { result, properties } şemasında\n\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers (servise taşındı) ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  } // ...existing code...\n  // flat (Type/Key/Value) -> { Parameters, Header, OrderDetails: { IbanHesap[], Details[] } }\n\n\n  transformBtmJson(flatData) {\n    const out = {\n      Parameters: {},\n      Header: {},\n      OrderDetails: {\n        IbanHesap: [],\n        Details: []\n      }\n    };\n    let currentIban = null;\n    let currentDetail = null;\n\n    for (const row of flatData || []) {\n      const {\n        Type,\n        Key,\n        Value\n      } = row || {};\n\n      if (Type === 'Parameters') {\n        out.Parameters[Key] = Value;\n        continue;\n      }\n\n      if (Type === 'Header') {\n        out.Header[Key] = Value;\n        continue;\n      }\n\n      if (Type === 'IbanHesap') {\n        if (!currentIban || Key === 'DestinationIban') {\n          currentIban = {};\n          out.OrderDetails.IbanHesap.push(currentIban);\n        }\n\n        currentIban[Key] = Value;\n        continue;\n      }\n\n      if (Type === 'Details') {\n        if (!currentDetail || Key === 'TotalCount' || Key === 'OrderDetails') {\n          currentDetail = {};\n          out.OrderDetails.Details.push(currentDetail);\n        }\n\n        currentDetail[Key] = Value;\n        continue;\n      }\n    }\n\n    return out;\n  }\n\n};\nBtmOrchestratorService = __decorate([Injectable({\n  providedIn: 'root'\n})], BtmOrchestratorService);\nexport { BtmOrchestratorService };","map":{"version":3,"mappings":"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","names":["Injectable","firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","xmlText","readFileAsText","csvString","uploadXml","pipe","err","csvOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","csvFile","File","type","result","rows","properties","headers","convert","pretty","transformBtmJson","prettyJson","via","_btmErr","converter","getConverter","Error","localResult","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","flatData","out","Parameters","Header","OrderDetails","IbanHesap","Details","currentIban","currentDetail","row","Type","Key","Value","push","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n    result: any[];         // flat tablo datası\r\n    properties: string[];  // tablo başlıkları\r\n    prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n    via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n    constructor(\r\n        private xmlBtm: XmlBtmService,\r\n        private fileConverter: FileConverterService,\r\n        private csvFileConverter: import('./csv-file-converter.service').CsvFileConverterService\r\n    ) { }\r\n\r\n    /**\r\n     * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n     * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n     */\r\n    async processXml(file: File): Promise<OrchestratedResult> {\r\n        const xmlText = await this.readFileAsText(file);\r\n\r\n        // 1) BTM'yi dene (2 sn timeout)\r\n        try {\r\n            const csvString: string = await firstValueFrom(\r\n                this.xmlBtm.uploadXml(xmlText).pipe(\r\n                    timeout(2000),\r\n                    catchError(err => throwError(() => err))\r\n                )\r\n            );\r\n\r\n            // 2) CSV -> flat JSON tablo (mevcut converter servisi ile)\r\n            // Varsayılan opsiyonlar, ihtiyaca göre UI'dan alınabilir\r\n            const csvOptions = {\r\n                hasHeader: true,\r\n                skipEmptyLines: true,\r\n                selectedDelimiter: ',',\r\n                doubleQuoteWrap: false,\r\n                selectedRowDelimiter: 'newline',\r\n                rowPrefix: '',\r\n                rowSuffix: '',\r\n                selectedEncoding: 'utf-8',\r\n                selectedQuoteOption: 'none',\r\n                trimWhitespace: true\r\n            };\r\n\r\n            // CSV string'i File objesine çeviriyoruz (converter File bekliyor)\r\n            const csvFile = new File([csvString], 'btm-output.csv', { type: 'text/csv' });\r\n            const { result: rows, properties: headers } = await this.csvFileConverter.convert(csvFile, csvOptions);\r\n\r\n            // 3) flat'ten okunaklı/gruplu JSON üret\r\n            const pretty = this.transformBtmJson(rows);\r\n\r\n            return { result: rows, properties: headers, prettyJson: pretty, via: 'btm' };\r\n        } catch (_btmErr) {\r\n            // 4) BTM başarısızsa local converter'a düş\r\n            const converter = this.fileConverter.getConverter('xml');\r\n            if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n            const localResult = await converter.convert(file, {\r\n                // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n            });\r\n\r\n            // localResult zaten { result, properties } şemasında\r\n            return { ...localResult, via: 'local' };\r\n        }\r\n    }\r\n\r\n    // --------- Helpers (servise taşındı) ---------\r\n\r\n    private readFileAsText(file: File): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = () => resolve(reader.result as string);\r\n            reader.onerror = (err) => reject(err);\r\n            reader.readAsText(file);\r\n        });\r\n    }\r\n\r\n    // ...existing code...\r\n\r\n    // flat (Type/Key/Value) -> { Parameters, Header, OrderDetails: { IbanHesap[], Details[] } }\r\n    private transformBtmJson(flatData: Array<{ Type: string; Key: string; Value: string }>) {\r\n        const out: any = {\r\n            Parameters: {},\r\n            Header: {},\r\n            OrderDetails: { IbanHesap: [], Details: [] }\r\n        };\r\n\r\n        let currentIban: any | null = null;\r\n        let currentDetail: any | null = null;\r\n\r\n        for (const row of flatData || []) {\r\n            const { Type, Key, Value } = row || ({} as any);\r\n\r\n            if (Type === 'Parameters') { out.Parameters[Key] = Value; continue; }\r\n            if (Type === 'Header') { out.Header[Key] = Value; continue; }\r\n\r\n            if (Type === 'IbanHesap') {\r\n                if (!currentIban || Key === 'DestinationIban') {\r\n                    currentIban = {};\r\n                    out.OrderDetails.IbanHesap.push(currentIban);\r\n                }\r\n                currentIban[Key] = Value;\r\n                continue;\r\n            }\r\n\r\n            if (Type === 'Details') {\r\n                if (!currentDetail || Key === 'TotalCount' || Key === 'OrderDetails') {\r\n                    currentDetail = {};\r\n                    out.OrderDetails.Details.push(currentDetail);\r\n                }\r\n                currentDetail[Key] = Value;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}