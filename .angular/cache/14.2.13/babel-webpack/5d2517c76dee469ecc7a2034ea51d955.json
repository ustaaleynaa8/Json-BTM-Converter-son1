{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n   * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err))));\n        console.log('BTM CSV çıktısı:', csvString); // Only detect delimiter for options\n\n        const delimiter = _this.detectDelimiter(csvString); // Always use CSV converter service for consistency\n\n\n        const defaultOptions = {\n          hasHeader: false,\n          skipEmptyLines: true,\n          selectedDelimiter: delimiter,\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        }; // BTM için her zaman header false ve algılanan delimiter kullan\n\n        const options = { ...(csvOptions || defaultOptions),\n          hasHeader: false,\n          selectedDelimiter: delimiter\n        }; // CSV içeriğini doğrudan inceleyelim - debug için\n\n        console.log('CSV içeriği örnek satırlar:', csvString.split('\\n').slice(0, 5).join('\\n')); // CSV servisi ile dönüşüm\n\n        const csvFile = new File([csvString], 'btm.csv', {\n          type: 'text/csv'\n        });\n        const converterResult = yield _this.csvFileConverter.convert(csvFile, options);\n        console.log('CSV converter returned:', converterResult); // Type/Key/Value format için özel dönüşüm - tüm muhtemel varyasyonlar için\n\n        const records = converterResult.result || []; // Debug - Tüm kayıtların yapısını göster\n\n        if (records.length > 0) {\n          console.log('İlk kayıt yapısı:', Object.keys(records[0]));\n          console.log('İlk kayıt değerleri:', Object.values(records[0]));\n        } // 1) İlk birkaç satıra bakarak Type/Key/Value formatı mı algıla\n\n\n        let isTypeKeyValue = false;\n        let typeField = '';\n        let keyField = '';\n        let valueField = ''; // Farklı format olasılıkları\n\n        const possibleFormats = [{\n          type: 'column1',\n          key: 'column2',\n          value: 'column3'\n        }, {\n          type: 'Type',\n          key: 'Key',\n          value: 'Value'\n        }, {\n          type: 'type',\n          key: 'key',\n          value: 'value'\n        }, {\n          type: '0',\n          key: '1',\n          value: '2'\n        } // header: false -> indeks bazlı\n        ];\n\n        for (const format of possibleFormats) {\n          // Bu format için gereken alanlar var mı?\n          const hasTypeField = records.length > 0 && records[0][format.type] !== undefined;\n          const hasKeyField = records.length > 0 && records[0][format.key] !== undefined;\n          const hasValueField = records.length > 0 && records[0][format.value] !== undefined;\n\n          if (hasTypeField && hasKeyField && hasValueField) {\n            // İlk birkaç satırda \"Parameters\", \"Header\" gibi tip değerleri var mı?\n            const typeValues = new Set(['Parameters', 'Header', 'Details']);\n            const sampleRows = records.slice(0, Math.min(5, records.length));\n            const matchingTypes = sampleRows.filter(r => typeValues.has(r[format.type]));\n\n            if (matchingTypes.length > 0) {\n              isTypeKeyValue = true;\n              typeField = format.type;\n              keyField = format.key;\n              valueField = format.value;\n              break;\n            }\n          }\n        } // Type/Key/Value format algılandıysa, gruplayıp dönüştür\n\n\n        if (isTypeKeyValue) {\n          // Her kayıt grubu için saklanan key/value çiftleri\n          const recordGroups = []; // Ortak Parameters ve Header kayıtları\n\n          const sharedRecords = {};\n          const detailsRecords = []; // Önce tüm Parameters ve Header kayıtlarını topla\n\n          for (const row of records) {\n            const type = row[typeField];\n            const key = row[keyField];\n            const value = row[valueField] || '';\n\n            if (type === 'Parameters' || type === 'Header') {\n              sharedRecords[key] = value;\n            } else if (type === 'Details') {\n              detailsRecords.push({\n                type,\n                key,\n                value\n              });\n            }\n          } // RegisterId'ye göre Detail kayıtlarını grupla\n          // RegisterId'ye göre Details kayıtlarını grupla\n          // Eğer RegisterId yoksa veya sadece bir tane varsa, tüm Details tek grupta olacak\n\n\n          const detailGroups = [];\n          let currentGroup = []; // RegisterId kontrolü\n\n          const hasRegisterIds = detailsRecords.some(d => d.key === 'RegisterId');\n\n          if (hasRegisterIds) {\n            // RegisterId'ye göre grupla\n            for (const detail of detailsRecords) {\n              if (detail.key === 'RegisterId' && currentGroup.length > 0) {\n                detailGroups.push([...currentGroup]);\n                currentGroup = [];\n              }\n\n              currentGroup.push(detail);\n            }\n          } else {\n            // Grup yapısı yoksa hepsini ekle\n            currentGroup = [...detailsRecords];\n          }\n\n          if (currentGroup.length > 0) {\n            detailGroups.push(currentGroup);\n          } // Her grup için flat object oluştur\n\n\n          if (detailGroups.length > 0) {\n            // Birden çok grup varsa, her biri için ayrı flat object\n            for (const group of detailGroups) {\n              const flatObject = { ...sharedRecords\n              };\n\n              for (const detail of group) {\n                flatObject[detail.key] = detail.value;\n              }\n\n              recordGroups.push(flatObject);\n            }\n          } else if (Object.keys(sharedRecords).length > 0) {\n            // Sadece ortak kayıtlar varsa, tek flat object\n            recordGroups.push({ ...sharedRecords\n            });\n          } else {\n            // Hiç kayıt yoksa, boş değil orijinal sonucu döndür\n            return { ...converterResult,\n              prettyJson: converterResult.result,\n              via: 'btm'\n            };\n          } // Tüm flat objelerin birleşik özellikleri\n\n\n          const allProperties = Array.from(new Set(recordGroups.flatMap(obj => Object.keys(obj))));\n          console.log('BTM Type/Key/Value formatı algılandı. Gruplar oluşturuldu:', recordGroups);\n          return {\n            result: recordGroups,\n            properties: allProperties,\n            prettyJson: recordGroups,\n            via: 'btm'\n          };\n        } // Normal CSV\n\n\n        return { ...converterResult,\n          prettyJson: converterResult.result,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 4) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        }); // localResult zaten { result, properties } şemasında\n\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers (servise taşındı) ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  } // Bu fonksiyonlar artık kullanılmadığı için kaldırıldı - CSV dönüşüm işlemleri CsvConverter servisine devredildi\n\n  /**\r\n   * Otomatik delimiter tespiti\r\n   */\n\n\n  detectDelimiter(csvString) {\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5); // İlk 5 satırı kontrol et\n\n    const delimiters = [',', ';', '\\t', '|'];\n    const counts = {};\n\n    for (const delimiter of delimiters) {\n      counts[delimiter] = 0;\n\n      for (const line of lines) {\n        // Quotes içindeki delimiter'ları sayma\n        let inQuotes = false;\n\n        for (let i = 0; i < line.length; i++) {\n          if (line[i] === '\"') {\n            inQuotes = !inQuotes;\n          } else if (line[i] === delimiter && !inQuotes) {\n            counts[delimiter]++;\n          }\n        }\n      }\n    } // En çok bulunan delimiter'ı döndür\n\n\n    let maxCount = 0;\n    let bestDelimiter = ',';\n\n    for (const [delimiter, count] of Object.entries(counts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        bestDelimiter = delimiter;\n      }\n    }\n\n    console.log('Delimiter tespiti:', counts, 'Seçilen:', bestDelimiter);\n    return bestDelimiter;\n  }\n  /**\r\n   * BTM'den gelen Type/Key/Value formatını düz objeye çevir\r\n   * Bu fonksiyon CSV dönüşüm sonucunda Type/Key/Value kolonları varsa kullanılır.\r\n   * Normal CSV dönüşümü için gereksizdir.\r\n   */\n\n\n  transformBtmJson(typedRows) {\n    // Tüm Key/Value çiftlerini tek bir objeye topla\n    const result = {};\n\n    for (const row of typedRows || []) {\n      const {\n        Key,\n        Value\n      } = row || {}; // Her Key/Value çiftini direkt objeye ekle\n\n      if (Key && Value !== undefined) {\n        result[Key] = Value;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","log","delimiter","detectDelimiter","defaultOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","options","split","slice","join","csvFile","File","type","converterResult","convert","records","result","length","Object","keys","values","isTypeKeyValue","typeField","keyField","valueField","possibleFormats","key","value","format","hasTypeField","undefined","hasKeyField","hasValueField","typeValues","Set","sampleRows","Math","min","matchingTypes","filter","r","has","recordGroups","sharedRecords","detailsRecords","row","push","detailGroups","currentGroup","hasRegisterIds","some","d","detail","group","flatObject","prettyJson","via","allProperties","Array","from","flatMap","obj","properties","_btmErr","converter","getConverter","Error","localResult","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","lines","trim","delimiters","counts","line","inQuotes","i","maxCount","bestDelimiter","count","entries","transformBtmJson","typedRows","Key","Value","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n    result: any[];         // flat tablo datası\r\n    properties: string[];  // tablo başlıkları\r\n    prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n    via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n    constructor(\r\n        private xmlBtm: XmlBtmService,\r\n        private fileConverter: FileConverterService,\r\n        private csvFileConverter: CsvFileConverterService\r\n    ) { }\r\n\r\n    /**\r\n     * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n     * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n     */\r\n    async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n        const xmlText = await this.readFileAsText(file);\r\n\r\n        // 1) BTM'yi dene (2 sn timeout)\r\n        try {\r\n            const csvString: string = await firstValueFrom(\r\n                this.xmlBtm.uploadXml(xmlText).pipe(\r\n                    timeout(2000),\r\n                    catchError(err => throwError(() => err))\r\n                )\r\n            );\r\n            \r\n            console.log('BTM CSV çıktısı:', csvString);\r\n\r\n            // Only detect delimiter for options\r\n            const delimiter = this.detectDelimiter(csvString);\r\n            \r\n            // Always use CSV converter service for consistency\r\n            const defaultOptions: CsvOptions = {\r\n                hasHeader: false,  // BTM Type/Key/Value kolonlar için header false\r\n                skipEmptyLines: true,\r\n                selectedDelimiter: delimiter,\r\n                doubleQuoteWrap: false,\r\n                selectedRowDelimiter: 'newline',\r\n                rowPrefix: '',\r\n                rowSuffix: '',\r\n                selectedEncoding: 'utf-8',\r\n                selectedQuoteOption: 'none',\r\n                trimWhitespace: true,\r\n            };\r\n\r\n            // BTM için her zaman header false ve algılanan delimiter kullan\r\n            const options: CsvOptions = {\r\n                ...(csvOptions || defaultOptions),\r\n                hasHeader: false,\r\n                selectedDelimiter: delimiter\r\n            };\r\n\r\n            // CSV içeriğini doğrudan inceleyelim - debug için\r\n            console.log('CSV içeriği örnek satırlar:', csvString.split('\\n').slice(0, 5).join('\\n'));\r\n            \r\n            // CSV servisi ile dönüşüm\r\n            const csvFile = new File([csvString], 'btm.csv', { type: 'text/csv' });\r\n            const converterResult = await this.csvFileConverter.convert(csvFile, options);\r\n            console.log('CSV converter returned:', converterResult);\r\n            \r\n            // Type/Key/Value format için özel dönüşüm - tüm muhtemel varyasyonlar için\r\n            const records: Array<Record<string, any>> = converterResult.result || [];\r\n            \r\n            // Debug - Tüm kayıtların yapısını göster\r\n            if (records.length > 0) {\r\n                console.log('İlk kayıt yapısı:', Object.keys(records[0]));\r\n                console.log('İlk kayıt değerleri:', Object.values(records[0]));\r\n            }\r\n            \r\n            // 1) İlk birkaç satıra bakarak Type/Key/Value formatı mı algıla\r\n            let isTypeKeyValue = false;\r\n            let typeField = '';\r\n            let keyField = '';\r\n            let valueField = '';\r\n            \r\n            // Farklı format olasılıkları\r\n            const possibleFormats = [\r\n                { type: 'column1', key: 'column2', value: 'column3' }, // header: false -> column1,2,3...\r\n                { type: 'Type', key: 'Key', value: 'Value' },          // header: true -> Type,Key,Value\r\n                { type: 'type', key: 'key', value: 'value' },          // header: true -> type,key,value\r\n                { type: '0', key: '1', value: '2' }                    // header: false -> indeks bazlı\r\n            ];\r\n            \r\n            for (const format of possibleFormats) {\r\n                // Bu format için gereken alanlar var mı?\r\n                const hasTypeField = records.length > 0 && records[0][format.type] !== undefined;\r\n                const hasKeyField = records.length > 0 && records[0][format.key] !== undefined;\r\n                const hasValueField = records.length > 0 && records[0][format.value] !== undefined;\r\n                \r\n                if (hasTypeField && hasKeyField && hasValueField) {\r\n                    // İlk birkaç satırda \"Parameters\", \"Header\" gibi tip değerleri var mı?\r\n                    const typeValues = new Set(['Parameters', 'Header', 'Details']);\r\n                    const sampleRows = records.slice(0, Math.min(5, records.length));\r\n                    const matchingTypes = sampleRows.filter((r: Record<string, any>) => typeValues.has(r[format.type]));\r\n                    \r\n                    if (matchingTypes.length > 0) {\r\n                        isTypeKeyValue = true;\r\n                        typeField = format.type;\r\n                        keyField = format.key;\r\n                        valueField = format.value;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Type/Key/Value format algılandıysa, gruplayıp dönüştür\r\n            if (isTypeKeyValue) {\r\n                // Her kayıt grubu için saklanan key/value çiftleri\r\n                const recordGroups: Record<string, any>[] = [];\r\n                \r\n                // Ortak Parameters ve Header kayıtları\r\n                const sharedRecords: Record<string, string> = {};\r\n                const detailsRecords: Array<{type: string, key: string, value: string}> = [];\r\n                \r\n                // Önce tüm Parameters ve Header kayıtlarını topla\r\n                for (const row of records) {\r\n                    const type = row[typeField];\r\n                    const key = row[keyField];\r\n                    const value = row[valueField] || '';\r\n                    \r\n                    if (type === 'Parameters' || type === 'Header') {\r\n                        sharedRecords[key] = value;\r\n                    } else if (type === 'Details') {\r\n                        detailsRecords.push({ type, key, value });\r\n                    }\r\n                }\r\n                \r\n                // RegisterId'ye göre Detail kayıtlarını grupla\r\n                // RegisterId'ye göre Details kayıtlarını grupla\r\n                // Eğer RegisterId yoksa veya sadece bir tane varsa, tüm Details tek grupta olacak\r\n                const detailGroups: Array<{type: string, key: string, value: string}[]> = [];\r\n                let currentGroup: Array<{type: string, key: string, value: string}> = [];\r\n                \r\n                // RegisterId kontrolü\r\n                const hasRegisterIds = detailsRecords.some(d => d.key === 'RegisterId');\r\n                \r\n                if (hasRegisterIds) {\r\n                    // RegisterId'ye göre grupla\r\n                    for (const detail of detailsRecords) {\r\n                        if (detail.key === 'RegisterId' && currentGroup.length > 0) {\r\n                            detailGroups.push([...currentGroup]);\r\n                            currentGroup = [];\r\n                        }\r\n                        currentGroup.push(detail);\r\n                    }\r\n                } else {\r\n                    // Grup yapısı yoksa hepsini ekle\r\n                    currentGroup = [...detailsRecords];\r\n                }\r\n                \r\n                if (currentGroup.length > 0) {\r\n                    detailGroups.push(currentGroup);\r\n                }\r\n                \r\n                // Her grup için flat object oluştur\r\n                if (detailGroups.length > 0) {\r\n                    // Birden çok grup varsa, her biri için ayrı flat object\r\n                    for (const group of detailGroups) {\r\n                        const flatObject = { ...sharedRecords };\r\n                        \r\n                        for (const detail of group) {\r\n                            flatObject[detail.key] = detail.value;\r\n                        }\r\n                        \r\n                        recordGroups.push(flatObject);\r\n                    }\r\n                } else if (Object.keys(sharedRecords).length > 0) {\r\n                    // Sadece ortak kayıtlar varsa, tek flat object\r\n                    recordGroups.push({ ...sharedRecords });\r\n                } else {\r\n                    // Hiç kayıt yoksa, boş değil orijinal sonucu döndür\r\n                    return {\r\n                        ...converterResult,\r\n                        prettyJson: converterResult.result,\r\n                        via: 'btm',\r\n                    };\r\n                }\r\n                \r\n                // Tüm flat objelerin birleşik özellikleri\r\n                const allProperties = Array.from(\r\n                    new Set(recordGroups.flatMap(obj => Object.keys(obj)))\r\n                );\r\n                \r\n                console.log('BTM Type/Key/Value formatı algılandı. Gruplar oluşturuldu:', \r\n                             recordGroups);\r\n                \r\n                return {\r\n                    result: recordGroups,\r\n                    properties: allProperties,\r\n                    prettyJson: recordGroups,\r\n                    via: 'btm',\r\n                };\r\n            }\r\n\r\n            // Normal CSV\r\n            return {\r\n                ...converterResult,\r\n                prettyJson: converterResult.result,\r\n                via: 'btm',\r\n            };\r\n        } catch (_btmErr) {\r\n            // 4) BTM başarısızsa local converter'a düş\r\n            const converter = this.fileConverter.getConverter('xml');\r\n            if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n            const localResult = await converter.convert(file, {\r\n                // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n            });\r\n\r\n            // localResult zaten { result, properties } şemasında\r\n            return { ...localResult, via: 'local' };\r\n        }\r\n    }\r\n\r\n    // --------- Helpers (servise taşındı) ---------\r\n\r\n    private readFileAsText(file: File): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = () => resolve(reader.result as string);\r\n            reader.onerror = (err) => reject(err);\r\n            reader.readAsText(file);\r\n        });\r\n    }\r\n\r\n    // Bu fonksiyonlar artık kullanılmadığı için kaldırıldı - CSV dönüşüm işlemleri CsvConverter servisine devredildi\r\n\r\n    /**\r\n     * Otomatik delimiter tespiti\r\n     */\r\n    private detectDelimiter(csvString: string): string {\r\n        const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5); // İlk 5 satırı kontrol et\r\n        const delimiters = [',', ';', '\\t', '|'];\r\n        const counts: { [key: string]: number } = {};\r\n\r\n        for (const delimiter of delimiters) {\r\n            counts[delimiter] = 0;\r\n            for (const line of lines) {\r\n                // Quotes içindeki delimiter'ları sayma\r\n                let inQuotes = false;\r\n                for (let i = 0; i < line.length; i++) {\r\n                    if (line[i] === '\"') {\r\n                        inQuotes = !inQuotes;\r\n                    } else if (line[i] === delimiter && !inQuotes) {\r\n                        counts[delimiter]++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // En çok bulunan delimiter'ı döndür\r\n        let maxCount = 0;\r\n        let bestDelimiter = ',';\r\n        for (const [delimiter, count] of Object.entries(counts)) {\r\n            if (count > maxCount) {\r\n                maxCount = count;\r\n                bestDelimiter = delimiter;\r\n            }\r\n        }\r\n\r\n        console.log('Delimiter tespiti:', counts, 'Seçilen:', bestDelimiter);\r\n        return bestDelimiter;\r\n    }\r\n\r\n    /**\r\n     * BTM'den gelen Type/Key/Value formatını düz objeye çevir\r\n     * Bu fonksiyon CSV dönüşüm sonucunda Type/Key/Value kolonları varsa kullanılır.\r\n     * Normal CSV dönüşümü için gereksizdir.\r\n     */\r\n    private transformBtmJson(typedRows: Array<{ Type?: string; Key?: string; Value?: string }>) {\r\n        // Tüm Key/Value çiftlerini tek bir objeye topla\r\n        const result: Record<string, string> = {};\r\n        \r\n        for (const row of typedRows || []) {\r\n            const { Key, Value } = row || {};\r\n            // Her Key/Value çiftini direkt objeye ekle\r\n            if (Key && Value !== undefined) {\r\n                result[Key] = Value;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}