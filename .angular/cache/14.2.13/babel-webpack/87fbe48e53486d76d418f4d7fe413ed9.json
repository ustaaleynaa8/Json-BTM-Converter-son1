{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n   * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n   */\n\n\n  processXml(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err))));\n        console.log('BTM CSV çıktısı:', csvString); // CSV string'i satırlara ayır\n\n        const lines = csvString.trim().split(/\\r?\\n/);\n        console.log('BTM CSV satırları:', lines); // Her satırı Type,Key,Value formatında parse et\n\n        const typedRecords = [];\n        lines.forEach(line => {\n          const [type, key, value] = line.split(',').map(v => v.trim());\n\n          if (type && key) {\n            typedRecords.push({\n              Type: type,\n              Key: key,\n              Value: value || ''\n            });\n          }\n        }); // Her kayıt grubu için yeni array\n\n        const recordGroups = [];\n        let currentGroup = [];\n        let hasFoundDetails = false; // Parameters ve Header kayıtlarını tüm gruplarda kullanmak için sakla\n\n        const sharedRecords = typedRecords.filter(r => r.Type === 'Parameters' || r.Type === 'Header'); // Details kayıtlarını grupla\n\n        typedRecords.forEach(record => {\n          if (record.Type === 'Details') {\n            hasFoundDetails = true;\n\n            if (record.Key === 'RegisterId' && currentGroup.length > 0) {\n              // Yeni grup başlıyor, mevcut grubu kaydet\n              recordGroups.push([...sharedRecords, ...currentGroup]);\n              currentGroup = [];\n            }\n\n            currentGroup.push(record);\n          }\n        }); // Son grubu da ekle\n\n        if (currentGroup.length > 0) {\n          recordGroups.push([...sharedRecords, ...currentGroup]);\n        } // Hiç Details yoksa, tek grup olarak Parameters/Header kayıtlarını kullan\n\n\n        if (!hasFoundDetails && sharedRecords.length > 0) {\n          recordGroups.push(sharedRecords);\n        }\n\n        console.log('Kayıt grupları:', recordGroups); // İlk grubu kullan veya boş array döndür\n\n        const rows = recordGroups.length > 0 ? recordGroups[0] : [];\n        const properties = ['Type', 'Key', 'Value']; // Pretty JSON için grupları kullan\n\n        const pretty = recordGroups.map(group => {\n          return _this.transformBtmJson(group);\n        });\n        return {\n          result: rows,\n          properties,\n          prettyJson: pretty,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 4) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        }); // localResult zaten { result, properties } şemasında\n\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers (servise taşındı) ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /**\r\n   * Geliştirilmiş CSV parser - quoted değerleri ve farklı delimiter'ları destekler\r\n   */\n\n\n  parseCsvString(csvString, delimiter = ',') {\n    const lines = csvString.trim().split(/\\r?\\n/);\n    const result = [];\n\n    for (const line of lines) {\n      if (!line.trim()) continue; // Boş satırları atla\n\n      const row = this.parseCsvLine(line, delimiter);\n      result.push(row);\n    }\n\n    return result;\n  }\n  /**\r\n   * Tek bir CSV satırını parse eder - quoted değerleri ve delimiter'ları düzgün işler\r\n   */\n\n\n  parseCsvLine(line, delimiter = ',') {\n    const result = [];\n    let current = '';\n    let inQuotes = false;\n    let i = 0;\n\n    while (i < line.length) {\n      const char = line[i];\n      const nextChar = line[i + 1];\n\n      if (char === '\"') {\n        if (inQuotes && nextChar === '\"') {\n          // Escaped quote (\"\")\n          current += '\"';\n          i += 2;\n        } else {\n          // Toggle quote state\n          inQuotes = !inQuotes;\n          i++;\n        }\n      } else if (char === delimiter && !inQuotes) {\n        // Field separator outside of quotes\n        result.push(current.trim());\n        current = '';\n        i++;\n      } else {\n        // Regular character\n        current += char;\n        i++;\n      }\n    } // Add the last field\n\n\n    result.push(current.trim()); // Clean up quotes from values if needed\n\n    return result.map(value => {\n      // Remove surrounding quotes if present\n      if (value.startsWith('\"') && value.endsWith('\"')) {\n        return value.slice(1, -1);\n      }\n\n      return value;\n    });\n  }\n  /**\r\n   * Otomatik delimiter tespiti\r\n   */\n\n\n  detectDelimiter(csvString) {\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5); // İlk 5 satırı kontrol et\n\n    const delimiters = [',', ';', '\\t', '|'];\n    const counts = {};\n\n    for (const delimiter of delimiters) {\n      counts[delimiter] = 0;\n\n      for (const line of lines) {\n        // Quotes içindeki delimiter'ları sayma\n        let inQuotes = false;\n\n        for (let i = 0; i < line.length; i++) {\n          if (line[i] === '\"') {\n            inQuotes = !inQuotes;\n          } else if (line[i] === delimiter && !inQuotes) {\n            counts[delimiter]++;\n          }\n        }\n      }\n    } // En çok bulunan delimiter'ı döndür\n\n\n    let maxCount = 0;\n    let bestDelimiter = ',';\n\n    for (const [delimiter, count] of Object.entries(counts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        bestDelimiter = delimiter;\n      }\n    }\n\n    console.log('Delimiter tespiti:', counts, 'Seçilen:', bestDelimiter);\n    return bestDelimiter;\n  } // BTM'den gelen Type/Key/Value formatını düz objeye çevir\n\n\n  transformBtmJson(flatData) {\n    // Tüm Key/Value çiftlerini tek bir objeye topla\n    const result = {};\n\n    for (const row of flatData || []) {\n      const {\n        Key,\n        Value\n      } = row || {}; // Her Key/Value çiftini direkt objeye ekle\n\n      if (Key && Value !== undefined) {\n        result[Key] = Value;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","log","lines","trim","split","typedRecords","forEach","line","type","key","value","map","v","push","Type","Key","Value","recordGroups","currentGroup","hasFoundDetails","sharedRecords","filter","r","record","length","rows","properties","pretty","group","transformBtmJson","result","prettyJson","via","_btmErr","converter","getConverter","Error","localResult","convert","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","parseCsvString","delimiter","row","parseCsvLine","current","inQuotes","i","char","nextChar","startsWith","endsWith","slice","detectDelimiter","delimiters","counts","maxCount","bestDelimiter","count","Object","entries","flatData","undefined","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n    result: any[];         // flat tablo datası\r\n    properties: string[];  // tablo başlıkları\r\n    prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n    via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n    constructor(\r\n        private xmlBtm: XmlBtmService,\r\n        private fileConverter: FileConverterService,\r\n        private csvFileConverter: CsvFileConverterService\r\n    ) { }\r\n\r\n    /**\r\n     * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n     * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n     */\r\n    async processXml(file: File): Promise<OrchestratedResult> {\r\n        const xmlText = await this.readFileAsText(file);\r\n\r\n        // 1) BTM'yi dene (2 sn timeout)\r\n        try {\r\n            const csvString: string = await firstValueFrom(\r\n                this.xmlBtm.uploadXml(xmlText).pipe(\r\n                    timeout(2000),\r\n                    catchError(err => throwError(() => err))\r\n                )\r\n            );\r\n            \r\n            console.log('BTM CSV çıktısı:', csvString);\r\n\r\n            // CSV string'i satırlara ayır\r\n            const lines = csvString.trim().split(/\\r?\\n/);\r\n            console.log('BTM CSV satırları:', lines);\r\n\r\n            interface TypedRecord {\r\n                Type: string;\r\n                Key: string;\r\n                Value: string;\r\n            }\r\n\r\n            // Her satırı Type,Key,Value formatında parse et\r\n            const typedRecords: TypedRecord[] = [];\r\n\r\n            lines.forEach(line => {\r\n                const [type, key, value] = line.split(',').map(v => v.trim());\r\n                if (type && key) {\r\n                    typedRecords.push({\r\n                        Type: type,\r\n                        Key: key,\r\n                        Value: value || ''\r\n                    });\r\n                }\r\n            });\r\n\r\n            // Her kayıt grubu için yeni array\r\n            const recordGroups: TypedRecord[][] = [];\r\n            let currentGroup: TypedRecord[] = [];\r\n            let hasFoundDetails = false;\r\n\r\n            // Parameters ve Header kayıtlarını tüm gruplarda kullanmak için sakla\r\n            const sharedRecords = typedRecords.filter(r => \r\n                r.Type === 'Parameters' || r.Type === 'Header');\r\n\r\n            // Details kayıtlarını grupla\r\n            typedRecords.forEach(record => {\r\n                if (record.Type === 'Details') {\r\n                    hasFoundDetails = true;\r\n                    if (record.Key === 'RegisterId' && currentGroup.length > 0) {\r\n                        // Yeni grup başlıyor, mevcut grubu kaydet\r\n                        recordGroups.push([...sharedRecords, ...currentGroup]);\r\n                        currentGroup = [];\r\n                    }\r\n                    currentGroup.push(record);\r\n                }\r\n            });\r\n\r\n            // Son grubu da ekle\r\n            if (currentGroup.length > 0) {\r\n                recordGroups.push([...sharedRecords, ...currentGroup]);\r\n            }\r\n\r\n            // Hiç Details yoksa, tek grup olarak Parameters/Header kayıtlarını kullan\r\n            if (!hasFoundDetails && sharedRecords.length > 0) {\r\n                recordGroups.push(sharedRecords);\r\n            }\r\n\r\n            console.log('Kayıt grupları:', recordGroups);\r\n            \r\n            // İlk grubu kullan veya boş array döndür\r\n            const rows = recordGroups.length > 0 ? recordGroups[0] : [];\r\n            const properties = ['Type', 'Key', 'Value'];\r\n            \r\n            // Pretty JSON için grupları kullan\r\n            const pretty = recordGroups.map(group => {\r\n                return this.transformBtmJson(group);\r\n            });\r\n            \r\n            return { \r\n                result: rows,\r\n                properties,\r\n                prettyJson: pretty,\r\n                via: 'btm' \r\n            };\r\n        } catch (_btmErr) {\r\n            // 4) BTM başarısızsa local converter'a düş\r\n            const converter = this.fileConverter.getConverter('xml');\r\n            if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n            const localResult = await converter.convert(file, {\r\n                // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n            });\r\n\r\n            // localResult zaten { result, properties } şemasında\r\n            return { ...localResult, via: 'local' };\r\n        }\r\n    }\r\n\r\n    // --------- Helpers (servise taşındı) ---------\r\n\r\n    private readFileAsText(file: File): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = () => resolve(reader.result as string);\r\n            reader.onerror = (err) => reject(err);\r\n            reader.readAsText(file);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Geliştirilmiş CSV parser - quoted değerleri ve farklı delimiter'ları destekler\r\n     */\r\n    private parseCsvString(csvString: string, delimiter: string = ','): string[][] {\r\n        const lines = csvString.trim().split(/\\r?\\n/);\r\n        const result: string[][] = [];\r\n\r\n        for (const line of lines) {\r\n            if (!line.trim()) continue; // Boş satırları atla\r\n            \r\n            const row = this.parseCsvLine(line, delimiter);\r\n            result.push(row);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Tek bir CSV satırını parse eder - quoted değerleri ve delimiter'ları düzgün işler\r\n     */\r\n    private parseCsvLine(line: string, delimiter: string = ','): string[] {\r\n        const result: string[] = [];\r\n        let current = '';\r\n        let inQuotes = false;\r\n        let i = 0;\r\n\r\n        while (i < line.length) {\r\n            const char = line[i];\r\n            const nextChar = line[i + 1];\r\n\r\n            if (char === '\"') {\r\n                if (inQuotes && nextChar === '\"') {\r\n                    // Escaped quote (\"\")\r\n                    current += '\"';\r\n                    i += 2;\r\n                } else {\r\n                    // Toggle quote state\r\n                    inQuotes = !inQuotes;\r\n                    i++;\r\n                }\r\n            } else if (char === delimiter && !inQuotes) {\r\n                // Field separator outside of quotes\r\n                result.push(current.trim());\r\n                current = '';\r\n                i++;\r\n            } else {\r\n                // Regular character\r\n                current += char;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Add the last field\r\n        result.push(current.trim());\r\n\r\n        // Clean up quotes from values if needed\r\n        return result.map(value => {\r\n            // Remove surrounding quotes if present\r\n            if (value.startsWith('\"') && value.endsWith('\"')) {\r\n                return value.slice(1, -1);\r\n            }\r\n            return value;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Otomatik delimiter tespiti\r\n     */\r\n    private detectDelimiter(csvString: string): string {\r\n        const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5); // İlk 5 satırı kontrol et\r\n        const delimiters = [',', ';', '\\t', '|'];\r\n        const counts: { [key: string]: number } = {};\r\n\r\n        for (const delimiter of delimiters) {\r\n            counts[delimiter] = 0;\r\n            for (const line of lines) {\r\n                // Quotes içindeki delimiter'ları sayma\r\n                let inQuotes = false;\r\n                for (let i = 0; i < line.length; i++) {\r\n                    if (line[i] === '\"') {\r\n                        inQuotes = !inQuotes;\r\n                    } else if (line[i] === delimiter && !inQuotes) {\r\n                        counts[delimiter]++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // En çok bulunan delimiter'ı döndür\r\n        let maxCount = 0;\r\n        let bestDelimiter = ',';\r\n        for (const [delimiter, count] of Object.entries(counts)) {\r\n            if (count > maxCount) {\r\n                maxCount = count;\r\n                bestDelimiter = delimiter;\r\n            }\r\n        }\r\n\r\n        console.log('Delimiter tespiti:', counts, 'Seçilen:', bestDelimiter);\r\n        return bestDelimiter;\r\n    }\r\n\r\n    // BTM'den gelen Type/Key/Value formatını düz objeye çevir\r\n    private transformBtmJson(flatData: Array<{ Type: string; Key: string; Value: string }>) {\r\n        // Tüm Key/Value çiftlerini tek bir objeye topla\r\n        const result: any = {};\r\n        \r\n        for (const row of flatData || []) {\r\n            const { Key, Value } = row || ({} as any);\r\n            // Her Key/Value çiftini direkt objeye ekle\r\n            if (Key && Value !== undefined) {\r\n                result[Key] = Value;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}