{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n   * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n   */\n\n\n  processXml(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err))));\n        console.log('BTM CSV çıktısı:', csvString); // 2) CSV -> flat JSON tablo (mevcut converter servisi ile)\n        // Varsayılan opsiyonlar, ihtiyaca göre UI'dan alınabilir\n\n        const csvOptions = {\n          hasHeader: true,\n          skipEmptyLines: true,\n          selectedDelimiter: ',',\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        };\n        console.log('BTM CSV string:', csvString); // BTM'den gelen veriyi parse et\n\n        const lines = csvString.trim().split(/\\r?\\n/); // Tüm olası kolonları topla\n\n        const allKeys = new Set();\n        lines.forEach(line => {\n          const [_type, key] = line.split(',').map(v => v.trim());\n          if (key) allKeys.add(key);\n        }); // Sıralı kolon listesi (sabit sırada olması için)\n\n        const orderedColumns = [// Önemli kolonlar önce\n        'RegisterId', 'OrderFileId', 'ProductId', 'SubProductId', 'OperationCode', // Diğer kolonlar alfabetik\n        ...Array.from(allKeys).filter(k => !['RegisterId', 'OrderFileId', 'ProductId', 'SubProductId', 'OperationCode'].includes(k)).sort()]; // Boş kayıt şablonu (tüm kolonlar boş string ile)\n\n        const emptyRecord = orderedColumns.reduce((acc, key) => {\n          acc[key] = '';\n          return acc;\n        }, {});\n        const records = [];\n        const baseMeta = Object.assign({}, emptyRecord);\n        let current = Object.assign({}, emptyRecord); // Önce Parameters ve Header bilgilerini topla\n\n        lines.forEach(line => {\n          const [_type, key, value] = line.split(',').map(v => v.trim());\n\n          if (_type === 'Parameters' || _type === 'Header') {\n            baseMeta[key] = value;\n          }\n        }); // Sonra Details kayıtlarını işle\n\n        lines.forEach(line => {\n          const [_type, key, value] = line.split(',').map(v => v.trim());\n\n          if (_type === 'Details') {\n            // Yeni Detail kaydı başlat\n            if (key === 'RegisterId') {\n              if (Object.keys(current).length > 0) {\n                records.push(Object.assign({}, current));\n              } // Yeni kayıt için base meta bilgileri kopyala\n\n\n              current = Object.assign({}, baseMeta);\n            }\n\n            current[key] = value;\n          }\n        }); // Son kaydı da ekle\n\n        if (Object.keys(current).length > 0) {\n          records.push(Object.assign({}, current));\n        }\n\n        console.log('Tüm kayıtlar:', records); // Array olarak dön\n\n        const rows = records;\n        const properties = Array.from(new Set(records.flatMap(obj => Object.keys(obj))));\n        const pretty = records; // Aynı array'i pretty olarak da kullan\n\n        return {\n          result: rows,\n          properties,\n          prettyJson: pretty,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 4) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        }); // localResult zaten { result, properties } şemasında\n\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers (servise taşındı) ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  } // ...existing code...\n  // BTM'den gelen Type/Key/Value formatını düz objeye çevir\n\n\n  transformBtmJson(flatData) {\n    // Tüm Key/Value çiftlerini tek bir objeye topla\n    const result = {};\n\n    for (const row of flatData || []) {\n      const {\n        Key,\n        Value\n      } = row || {}; // Her Key/Value çiftini direkt objeye ekle\n\n      if (Key && Value !== undefined) {\n        result[Key] = Value;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","log","csvOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","lines","trim","split","allKeys","Set","forEach","line","_type","key","map","v","add","orderedColumns","Array","from","filter","k","includes","sort","emptyRecord","reduce","acc","records","baseMeta","Object","assign","current","value","keys","length","push","rows","properties","flatMap","obj","pretty","result","prettyJson","via","_btmErr","converter","getConverter","Error","localResult","convert","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","transformBtmJson","flatData","row","Key","Value","undefined","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n    result: any[];         // flat tablo datası\r\n    properties: string[];  // tablo başlıkları\r\n    prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n    via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n    constructor(\r\n        private xmlBtm: XmlBtmService,\r\n        private fileConverter: FileConverterService,\r\n        private csvFileConverter: CsvFileConverterService\r\n    ) { }\r\n\r\n    /**\r\n     * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n     * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n     */\r\n    async processXml(file: File): Promise<OrchestratedResult> {\r\n        const xmlText = await this.readFileAsText(file);\r\n\r\n        // 1) BTM'yi dene (2 sn timeout)\r\n        try {\r\n            const csvString: string = await firstValueFrom(\r\n                this.xmlBtm.uploadXml(xmlText).pipe(\r\n                    timeout(2000),\r\n                    catchError(err => throwError(() => err))\r\n                )\r\n            );\r\n            \r\n            console.log('BTM CSV çıktısı:', csvString);\r\n\r\n            // 2) CSV -> flat JSON tablo (mevcut converter servisi ile)\r\n            // Varsayılan opsiyonlar, ihtiyaca göre UI'dan alınabilir\r\n            const csvOptions = {\r\n                hasHeader: true,\r\n                skipEmptyLines: true,\r\n                selectedDelimiter: ',',\r\n                doubleQuoteWrap: false,\r\n                selectedRowDelimiter: 'newline',\r\n                rowPrefix: '',\r\n                rowSuffix: '',\r\n                selectedEncoding: 'utf-8',\r\n                selectedQuoteOption: 'none',\r\n                trimWhitespace: true\r\n            };\r\n\r\n            console.log('BTM CSV string:', csvString);\r\n            \r\n            // BTM'den gelen veriyi parse et\r\n            const lines = csvString.trim().split(/\\r?\\n/);\r\n            \r\n            // Tüm olası kolonları topla\r\n            const allKeys = new Set<string>();\r\n            lines.forEach(line => {\r\n                const [_type, key] = line.split(',').map(v => v.trim());\r\n                if (key) allKeys.add(key);\r\n            });\r\n            \r\n            // Sıralı kolon listesi (sabit sırada olması için)\r\n            const orderedColumns = [\r\n                // Önemli kolonlar önce\r\n                'RegisterId',\r\n                'OrderFileId',\r\n                'ProductId',\r\n                'SubProductId',\r\n                'OperationCode',\r\n                // Diğer kolonlar alfabetik\r\n                ...Array.from(allKeys)\r\n                    .filter(k => !['RegisterId', 'OrderFileId', 'ProductId', 'SubProductId', 'OperationCode'].includes(k))\r\n                    .sort()\r\n            ];\r\n            \r\n            // Boş kayıt şablonu (tüm kolonlar boş string ile)\r\n            const emptyRecord = orderedColumns.reduce((acc, key) => {\r\n                acc[key] = '';\r\n                return acc;\r\n            }, {} as Record<string, any>);\r\n            \r\n            const records: Record<string, any>[] = [];\r\n            const baseMeta: Record<string, any> = Object.assign({}, emptyRecord);\r\n            let current: Record<string, any> = Object.assign({}, emptyRecord);\r\n            \r\n            // Önce Parameters ve Header bilgilerini topla\r\n            lines.forEach(line => {\r\n                const [_type, key, value] = line.split(',').map(v => v.trim());\r\n                if (_type === 'Parameters' || _type === 'Header') {\r\n                    baseMeta[key] = value;\r\n                }\r\n            });\r\n            \r\n            // Sonra Details kayıtlarını işle\r\n            lines.forEach(line => {\r\n                const [_type, key, value] = line.split(',').map(v => v.trim());\r\n                if (_type === 'Details') {\r\n                    // Yeni Detail kaydı başlat\r\n                    if (key === 'RegisterId') {\r\n                        if (Object.keys(current).length > 0) {\r\n                            records.push(Object.assign({}, current));\r\n                        }\r\n                        // Yeni kayıt için base meta bilgileri kopyala\r\n                        current = Object.assign({}, baseMeta);\r\n                    }\r\n                    current[key] = value;\r\n                }\r\n            });\r\n            \r\n            // Son kaydı da ekle\r\n            if (Object.keys(current).length > 0) {\r\n                records.push(Object.assign({}, current));\r\n            }\r\n            \r\n            console.log('Tüm kayıtlar:', records);\r\n            \r\n            // Array olarak dön\r\n            const rows = records;\r\n            const properties = Array.from(new Set(records.flatMap(obj => Object.keys(obj))));\r\n            const pretty = records; // Aynı array'i pretty olarak da kullan\r\n            return { result: rows, properties, prettyJson: pretty, via: 'btm' };\r\n        } catch (_btmErr) {\r\n            // 4) BTM başarısızsa local converter'a düş\r\n            const converter = this.fileConverter.getConverter('xml');\r\n            if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n            const localResult = await converter.convert(file, {\r\n                // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n            });\r\n\r\n            // localResult zaten { result, properties } şemasında\r\n            return { ...localResult, via: 'local' };\r\n        }\r\n    }\r\n\r\n    // --------- Helpers (servise taşındı) ---------\r\n\r\n    private readFileAsText(file: File): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = () => resolve(reader.result as string);\r\n            reader.onerror = (err) => reject(err);\r\n            reader.readAsText(file);\r\n        });\r\n    }\r\n\r\n    // ...existing code...\r\n\r\n    // BTM'den gelen Type/Key/Value formatını düz objeye çevir\r\n    private transformBtmJson(flatData: Array<{ Type: string; Key: string; Value: string }>) {\r\n        // Tüm Key/Value çiftlerini tek bir objeye topla\r\n        const result: any = {};\r\n        \r\n        for (const row of flatData || []) {\r\n            const { Key, Value } = row || ({} as any);\r\n            // Her Key/Value çiftini direkt objeye ekle\r\n            if (Key && Value !== undefined) {\r\n                result[Key] = Value;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}