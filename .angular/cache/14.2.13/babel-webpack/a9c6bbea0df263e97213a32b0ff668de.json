{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/JsonConverter-Btm/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(5000), catchError(err => {\n          console.error('BTM service error:', err);\n          return throwError(() => new Error('BTM servisine ulaşılamadı veya bir hata oluştu.'));\n        })));\n        console.log('BTM\\'den CSV metni alındı, sıralı işleme başlıyor...'); // BTM çıktısını doğrudan kendi sıralı işleyicimizle dönüştür\n\n        const btmResult = _this.transformBtmCsv(csvString); // Eğer dönüşüm başarılıysa, dönüştürülmüş sonucu döndür\n\n\n        if (btmResult.processedData.length > 0) {\n          console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt');\n          const properties = ['DestinationIban', 'FinalAccountNo', 'TotalCount', 'OrderDetails', 'TransferAmount', 'TotalAmount', 'RegisterId'];\n          return {\n            result: btmResult.processedData,\n            properties,\n            prettyJson: btmResult.processedData,\n            via: 'btm_sequential',\n            parametersData: btmResult.parametersData,\n            headerData: btmResult.headerData\n          };\n        } // Eğer sonuç boşsa, fallback mekanizmasını tetikle\n\n\n        throw new Error('BTM dönüşümü sonuç üretmedi.');\n      } catch (err) {\n        console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message); // 2) BTM başarısızsa local XML converter'a düş\n\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) {\n          throw new Error('XML dönüştürücü bulunamadı (local).');\n        }\n\n        const localResult = yield converter.convert(file, {// UI'dan parametre gelirse burada forward edebilirsin\n        });\n        return {\n          result: localResult.result,\n          properties: localResult.properties,\n          prettyJson: localResult.result,\n          via: 'local',\n          parametersData: [],\n          headerData: []\n        };\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /**\r\n   * BTM'den gelen CSV'yi sıralı işleyerek dönüştürür.\r\n   * Gruplama yerine, satırların sırasına göre mantıksal kayıtlar oluşturur.\r\n   */\n\n\n  transformBtmCsv(csv) {\n    const rows = this.parseTypeKeyValueCsv(csv);\n\n    if (rows.length === 0) {\n      return {\n        processedData: [],\n        parametersData: [],\n        headerData: [],\n        rawRows: []\n      };\n    }\n\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\n    const headerData = this.extractKeyValue(rows, 'Header');\n    const processedData = [];\n    let currentRecord = {}; // 'IbanHesap' ve 'DestinationIban' ikilisi yeni bir kaydın başlangıcıdır.\n\n    for (const row of rows) {\n      if (row.type === 'IbanHesap' && row.key === 'DestinationIban') {\n        // Mevcut bir kayıt varsa listeye ekle ve yenisini başlat\n        if (Object.keys(currentRecord).length > 0) {\n          processedData.push(currentRecord);\n        }\n\n        currentRecord = {}; // Kaydı sıfırla\n      } // Sadece IbanHesap ve Details tiplerini kayda ekle\n\n\n      if (row.type === 'IbanHesap' || row.type === 'Details') {\n        currentRecord[row.key] = row.value;\n      }\n    } // Döngü bittikten sonra son kaydı da listeye ekle\n\n\n    if (Object.keys(currentRecord).length > 0) {\n      processedData.push(currentRecord);\n    } // Toplanan verileri standart sütun adlarına normalleştir\n\n\n    const finalProcessedData = processedData.map(record => ({\n      DestinationIban: record['DestinationIban'] || record['Iban'] || '',\n      FinalAccountNo: record['FinalAccountNo'] || record['HesapNo'] || '',\n      TotalCount: record['TotalCount'] || '',\n      OrderDetails: record['OrderDetails'] || record['Detail'] || '',\n      TransferAmount: record['TransferAmount'] || record['Miktar'] || '',\n      TotalAmount: record['TotalAmount'] || record['ToplamTutar'] || record['Toplam'] || '',\n      RegisterId: record['RegisterId'] || record['Sicil'] || record['SicilNo'] || record['RegistrationId'] || ''\n    }));\n    console.log('Sıralı işleme sonrası oluşturulan data:', finalProcessedData.length, finalProcessedData);\n    return {\n      processedData: finalProcessedData,\n      parametersData,\n      headerData,\n      rawRows: rows\n    };\n  }\n\n  parseTypeKeyValueCsv(csv) {\n    const lines = csv.trim().split(/\\r?\\n/);\n    const rows = [];\n\n    for (const line of lines) {\n      if (line.trim()) {\n        const parts = line.split(',').map(part => part.trim().replace(/\"/g, ''));\n\n        if (parts.length >= 3) {\n          rows.push({\n            type: parts[0],\n            key: parts[1],\n            value: parts.slice(2).join(',')\n          });\n        }\n      }\n    }\n\n    return rows;\n  }\n\n  extractKeyValue(rows, type) {\n    return rows.filter(row => row.type === type).map(row => ({\n      key: row.key || '',\n      value: row.value || ''\n    }));\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["catchError","throwError","firstValueFrom","timeout","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","error","Error","log","btmResult","transformBtmCsv","processedData","length","properties","result","prettyJson","via","parametersData","headerData","message","converter","getConverter","localResult","convert","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","csv","rows","parseTypeKeyValueCsv","rawRows","extractKeyValue","currentRecord","row","type","key","Object","keys","push","value","finalProcessedData","map","record","DestinationIban","FinalAccountNo","TotalCount","OrderDetails","TransferAmount","TotalAmount","RegisterId","lines","trim","split","line","parts","part","replace","slice","join","filter","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\JsonConverter-Btm\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];\r\n  properties?: string[];\r\n  prettyJson?: any;\r\n  via: string;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n}\r\n\r\nexport interface BtmTransformResult {\r\n  processedData: Array<Record<string, string>>;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n  rawRows: any[];\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    // 1) BTM'yi dene\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(5000),\r\n          catchError(err => {\r\n            console.error('BTM service error:', err);\r\n            return throwError(() => new Error('BTM servisine ulaşılamadı veya bir hata oluştu.'));\r\n          })\r\n        )\r\n      );\r\n\r\n      console.log('BTM\\'den CSV metni alındı, sıralı işleme başlıyor...');\r\n\r\n      // BTM çıktısını doğrudan kendi sıralı işleyicimizle dönüştür\r\n      const btmResult = this.transformBtmCsv(csvString);\r\n\r\n      // Eğer dönüşüm başarılıysa, dönüştürülmüş sonucu döndür\r\n      if (btmResult.processedData.length > 0) {\r\n        console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt');\r\n\r\n        const properties = [\r\n          'DestinationIban', 'FinalAccountNo', 'TotalCount', 'OrderDetails',\r\n          'TransferAmount', 'TotalAmount', 'RegisterId'\r\n        ];\r\n\r\n        return {\r\n          result: btmResult.processedData,\r\n          properties,\r\n          prettyJson: btmResult.processedData,\r\n          via: 'btm_sequential',\r\n          parametersData: btmResult.parametersData,\r\n          headerData: btmResult.headerData\r\n        };\r\n      }\r\n\r\n      // Eğer sonuç boşsa, fallback mekanizmasını tetikle\r\n      throw new Error('BTM dönüşümü sonuç üretmedi.');\r\n\r\n    } catch (err: any) {\r\n      console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message);\r\n      \r\n      // 2) BTM başarısızsa local XML converter'a düş\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) {\r\n        throw new Error('XML dönüştürücü bulunamadı (local).');\r\n      }\r\n\r\n      const localResult = await converter.convert(file, {\r\n        // UI'dan parametre gelirse burada forward edebilirsin\r\n      });\r\n\r\n      return {\r\n        result: localResult.result,\r\n        properties: localResult.properties,\r\n        prettyJson: localResult.result,\r\n        via: 'local',\r\n        parametersData: [],\r\n        headerData: []\r\n      };\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * BTM'den gelen CSV'yi sıralı işleyerek dönüştürür.\r\n   * Gruplama yerine, satırların sırasına göre mantıksal kayıtlar oluşturur.\r\n   */\r\n  private transformBtmCsv(csv: string): BtmTransformResult {\r\n    const rows = this.parseTypeKeyValueCsv(csv);\r\n\r\n    if (rows.length === 0) {\r\n      return { processedData: [], parametersData: [], headerData: [], rawRows: [] };\r\n    }\r\n\r\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\r\n    const headerData     = this.extractKeyValue(rows, 'Header');\r\n\r\n    const processedData: Array<Record<string, string>> = [];\r\n    let currentRecord: Record<string, string> = {};\r\n\r\n    // 'IbanHesap' ve 'DestinationIban' ikilisi yeni bir kaydın başlangıcıdır.\r\n    for (const row of rows) {\r\n      if (row.type === 'IbanHesap' && row.key === 'DestinationIban') {\r\n        // Mevcut bir kayıt varsa listeye ekle ve yenisini başlat\r\n        if (Object.keys(currentRecord).length > 0) {\r\n          processedData.push(currentRecord);\r\n        }\r\n        currentRecord = {}; // Kaydı sıfırla\r\n      }\r\n\r\n      // Sadece IbanHesap ve Details tiplerini kayda ekle\r\n      if (row.type === 'IbanHesap' || row.type === 'Details') {\r\n        currentRecord[row.key] = row.value;\r\n      }\r\n    }\r\n\r\n    // Döngü bittikten sonra son kaydı da listeye ekle\r\n    if (Object.keys(currentRecord).length > 0) {\r\n      processedData.push(currentRecord);\r\n    }\r\n\r\n    // Toplanan verileri standart sütun adlarına normalleştir\r\n    const finalProcessedData = processedData.map(record => ({\r\n      DestinationIban: record['DestinationIban'] || record['Iban'] || '',\r\n      FinalAccountNo:  record['FinalAccountNo']  || record['HesapNo'] || '',\r\n      TotalCount:      record['TotalCount'] || '',\r\n      OrderDetails:    record['OrderDetails'] || record['Detail'] || '',\r\n      TransferAmount:  record['TransferAmount'] || record['Miktar'] || '',\r\n      TotalAmount:     record['TotalAmount'] || record['ToplamTutar'] || record['Toplam'] || '',\r\n      RegisterId:      record['RegisterId'] || record['Sicil'] || record['SicilNo'] || record['RegistrationId'] || ''\r\n    }));\r\n\r\n    console.log('Sıralı işleme sonrası oluşturulan data:', finalProcessedData.length, finalProcessedData);\r\n    return {\r\n      processedData: finalProcessedData,\r\n      parametersData,\r\n      headerData,\r\n      rawRows: rows\r\n    };\r\n  }\r\n\r\n  private parseTypeKeyValueCsv(csv: string): any[] {\r\n    const lines = csv.trim().split(/\\r?\\n/);\r\n    const rows: any[] = [];\r\n    \r\n    for (const line of lines) {\r\n      if (line.trim()) {\r\n        const parts = line.split(',').map(part => part.trim().replace(/\"/g, ''));\r\n        if (parts.length >= 3) {\r\n          rows.push({\r\n            type: parts[0],\r\n            key: parts[1],\r\n            value: parts.slice(2).join(',')\r\n          });\r\n        }\r\n      }\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  private extractKeyValue(rows: any[], type: string): Array<{ key: string; value: string }> {\r\n    return rows\r\n      .filter((row: any) => row.type === type)\r\n      .map((row: any) => ({ key: row.key || '', value: row.value || '' }));\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}