{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/JsonConverter-Btm/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file);\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(5000), catchError(err => {\n          console.error('BTM service error:', err); // Daha spesifik error message\n\n          const errorMsg = err?.error?.message || err?.message || 'BTM servisinde beklenmeyen bir hata oluştu';\n          return throwError(() => new Error(`BTM Servisi: ${errorMsg}`));\n        }))); // CSV string boş mu kontrol et\n\n        if (!csvString || csvString.trim().length === 0) {\n          throw new Error('BTM servisinden boş CSV yanıtı alındı');\n        }\n\n        const btmResult = _this.transformBtmCsv(csvString);\n\n        if (btmResult.processedData.length > 0) {\n          console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt'); // Tablo başlıkları için sadece anlamlı anahtarları topla\n\n          const properties = _this.extractMeaningfulProperties(btmResult.processedData);\n\n          return {\n            result: btmResult.processedData,\n            properties,\n            prettyJson: btmResult.processedData,\n            via: 'btm_grouped_final',\n            parametersData: btmResult.parametersData,\n            headerData: btmResult.headerData\n          };\n        }\n\n        throw new Error('BTM dönüşümü anlamlı bir sonuç üretmedi');\n      } catch (err) {\n        console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message);\n\n        try {\n          const converter = _this.fileConverter.getConverter('xml');\n\n          if (!converter) {\n            throw new Error('XML dönüştürücü bulunamadı (local)');\n          }\n\n          const localResult = yield converter.convert(file, {});\n          return {\n            result: localResult.result,\n            properties: localResult.properties,\n            prettyJson: localResult.result,\n            via: 'local',\n            parametersData: [],\n            headerData: []\n          };\n        } catch (localErr) {\n          // Hem BTM hem local başarısız olduysa, daha detaylı hata ver\n          throw new Error(`XML işlemi başarısız - BTM: ${err.message}, Local: ${localErr.message}`);\n        }\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(new Error('Dosya okuma hatası: ' + err));\n\n      reader.readAsText(file);\n    });\n  }\n  /**\r\n   * BTM'den gelen CSV'yi gruplayarak ve birleştirerek dönüştürür.\r\n   */\n\n\n  transformBtmCsv(csv) {\n    const rows = this.parseTypeKeyValueCsv(csv);\n\n    if (rows.length === 0) {\n      return {\n        processedData: [],\n        parametersData: [],\n        headerData: [],\n        rawRows: []\n      };\n    }\n\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\n    const headerData = this.extractKeyValue(rows, 'Header');\n    const paramObj = this.toObject(parametersData);\n    const headerObj = this.toObject(headerData);\n    const ibanGroups = this.groupByTypeAsObjects(rows, 'IbanHesap');\n    const detailGroups = this.groupByTypeAsObjects(rows, 'Details');\n    console.log(`Gruplar oluşturuldu: IbanHesap (${ibanGroups.length}), Details (${detailGroups.length})`);\n    const processedData = [];\n    const count = Math.max(ibanGroups.length, detailGroups.length);\n\n    for (let i = 0; i < count; i++) {\n      const iban = ibanGroups[i] || {};\n      const detail = detailGroups[i] || {}; // Önce ana verileri, sonra global verileri birleştir.\n      // Bu, aynı anahtar varsa (örn: TotalAmount) ana verinin öncelikli olmasını sağlar.\n\n      const mergedRecord = { ...paramObj,\n        ...headerObj,\n        ...iban,\n        ...detail\n      }; // Boş veya null değerleri temizle\n\n      const cleanedRecord = this.cleanRecord(mergedRecord);\n      processedData.push(cleanedRecord);\n    }\n\n    return {\n      processedData,\n      parametersData,\n      headerData,\n      rawRows: rows\n    };\n  }\n\n  parseTypeKeyValueCsv(csv) {\n    const lines = csv.trim().split(/\\r?\\n/);\n    const rows = []; // Başlık satırını atla (büyük/küçük harf duyarsız)\n\n    const contentLines = lines.filter(line => line.trim() && !line.toLowerCase().startsWith('type,key,value'));\n\n    for (const line of contentLines) {\n      // CSV parsing'i daha güvenli yap - virgülleri value içindeki virgüllerden ayır\n      const parts = line.split(',');\n\n      if (parts.length < 3) {\n        console.warn('Hatalı CSV satırı (3 bölümden az):', line);\n        continue;\n      }\n\n      const type = parts[0].trim();\n      const key = parts[1].trim(); // Değer, geri kalan her şeydir (virgül içerebilir)\n\n      const value = parts.slice(2).join(',').trim(); // Boş type veya key'leri atla\n\n      if (type && key) {\n        rows.push({\n          type,\n          key,\n          value\n        });\n      }\n    }\n\n    return rows;\n  }\n\n  extractKeyValue(rows, type) {\n    return rows.filter(row => row.type === type).map(row => ({\n      key: row.key,\n      value: row.value\n    }));\n  }\n\n  toObject(pairs) {\n    return pairs.reduce((obj, item) => {\n      if (item.key) {\n        // Boş anahtarları ekleme\n        obj[item.key] = item.value;\n      }\n\n      return obj;\n    }, {});\n  }\n  /**\r\n   * Satırları tipine göre mantıksal gruplara ayırır.\r\n   * Bir tipin ilk anahtarı tekrarlandığında yeni bir grup başlatır.\r\n   */\n\n\n  groupByTypeAsObjects(rows, type) {\n    const filteredRows = rows.filter(row => row.type === type);\n    if (filteredRows.length === 0) return [];\n    const groups = [];\n    let currentGroup = {}; // Grubun başlangıcını belirleyen anahtarı bul (ilk satırın anahtarı)\n\n    const firstKey = filteredRows[0].key;\n\n    for (const row of filteredRows) {\n      // Eğer başlangıç anahtarı tekrar ederse VE mevcut grup boş değilse, yeni grup başlat\n      if (row.key === firstKey && Object.keys(currentGroup).length > 0) {\n        groups.push(currentGroup);\n        currentGroup = {};\n      } // Anahtar boş değilse gruba ekle\n\n\n      if (row.key) {\n        currentGroup[row.key] = row.value;\n      }\n    } // Döngüden sonra kalan son grubu da ekle\n\n\n    if (Object.keys(currentGroup).length > 0) {\n      groups.push(currentGroup);\n    }\n\n    return groups;\n  }\n  /**\r\n   * Record'u temizler - boş/null değerleri kaldırır.\r\n   */\n\n\n  cleanRecord(record) {\n    const cleaned = {};\n\n    for (const [key, value] of Object.entries(record)) {\n      // Değerin null, undefined veya boş bir string olmadığını kontrol et\n      if (value != null && value.toString().trim() !== '') {\n        // Anahtarın da geçerli olduğundan emin ol\n        const cleanKey = key.trim();\n\n        if (cleanKey) {\n          cleaned[cleanKey] = value.toString().trim();\n        }\n      }\n    }\n\n    return cleaned;\n  }\n  /**\r\n   * Anlamlı property'leri çıkarır - boş veya gereksiz key'leri filtreler\r\n   */\n\n\n  extractMeaningfulProperties(data) {\n    const allKeys = new Set();\n    data.forEach(row => {\n      Object.keys(row).forEach(key => {\n        // Sadece anlamlı key'leri ekle (boş olmayan)\n        if (key && key.trim()) {\n          allKeys.add(key.trim());\n        }\n      });\n    }); // Anahtarları sıralayarak tutarlı bir kolon sırası elde et\n\n    return Array.from(allKeys).sort();\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["catchError","throwError","firstValueFrom","timeout","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","error","errorMsg","message","Error","trim","length","btmResult","transformBtmCsv","processedData","log","properties","extractMeaningfulProperties","result","prettyJson","via","parametersData","headerData","converter","getConverter","localResult","convert","localErr","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","csv","rows","parseTypeKeyValueCsv","rawRows","extractKeyValue","paramObj","toObject","headerObj","ibanGroups","groupByTypeAsObjects","detailGroups","count","Math","max","i","iban","detail","mergedRecord","cleanedRecord","cleanRecord","push","lines","split","contentLines","filter","line","toLowerCase","startsWith","parts","warn","type","key","value","slice","join","row","map","pairs","reduce","obj","item","filteredRows","groups","currentGroup","firstKey","Object","keys","record","cleaned","entries","toString","cleanKey","data","allKeys","Set","forEach","add","Array","from","sort","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\JsonConverter-Btm\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];\r\n  properties?: string[];\r\n  prettyJson?: any;\r\n  via: string;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n}\r\n\r\nexport interface BtmTransformResult {\r\n  processedData: Array<Record<string, string>>;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n  rawRows: any[];\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(5000),\r\n          catchError(err => {\r\n            console.error('BTM service error:', err);\r\n            // Daha spesifik error message\r\n            const errorMsg = err?.error?.message || err?.message || 'BTM servisinde beklenmeyen bir hata oluştu';\r\n            return throwError(() => new Error(`BTM Servisi: ${errorMsg}`));\r\n          })\r\n        )\r\n      );\r\n\r\n      // CSV string boş mu kontrol et\r\n      if (!csvString || csvString.trim().length === 0) {\r\n        throw new Error('BTM servisinden boş CSV yanıtı alındı');\r\n      }\r\n\r\n      const btmResult = this.transformBtmCsv(csvString);\r\n\r\n      if (btmResult.processedData.length > 0) {\r\n        console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt');\r\n\r\n        // Tablo başlıkları için sadece anlamlı anahtarları topla\r\n        const properties = this.extractMeaningfulProperties(btmResult.processedData);\r\n\r\n        return {\r\n          result: btmResult.processedData,\r\n          properties,\r\n          prettyJson: btmResult.processedData,\r\n          via: 'btm_grouped_final',\r\n          parametersData: btmResult.parametersData,\r\n          headerData: btmResult.headerData\r\n        };\r\n      }\r\n\r\n      throw new Error('BTM dönüşümü anlamlı bir sonuç üretmedi');\r\n\r\n    } catch (err: any) {\r\n      console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message);\r\n      \r\n      try {\r\n        const converter = this.fileConverter.getConverter('xml');\r\n        if (!converter) {\r\n          throw new Error('XML dönüştürücü bulunamadı (local)');\r\n        }\r\n        const localResult = await converter.convert(file, {});\r\n        return {\r\n          result: localResult.result,\r\n          properties: localResult.properties,\r\n          prettyJson: localResult.result,\r\n          via: 'local',\r\n          parametersData: [],\r\n          headerData: []\r\n        };\r\n      } catch (localErr: any) {\r\n        // Hem BTM hem local başarısız olduysa, daha detaylı hata ver\r\n        throw new Error(`XML işlemi başarısız - BTM: ${err.message}, Local: ${localErr.message}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(new Error('Dosya okuma hatası: ' + err));\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * BTM'den gelen CSV'yi gruplayarak ve birleştirerek dönüştürür.\r\n   */\r\n  private transformBtmCsv(csv: string): BtmTransformResult {\r\n    const rows = this.parseTypeKeyValueCsv(csv);\r\n    if (rows.length === 0) {\r\n      return { processedData: [], parametersData: [], headerData: [], rawRows: [] };\r\n    }\r\n\r\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\r\n    const headerData = this.extractKeyValue(rows, 'Header');\r\n    const paramObj = this.toObject(parametersData);\r\n    const headerObj = this.toObject(headerData);\r\n\r\n    const ibanGroups = this.groupByTypeAsObjects(rows, 'IbanHesap');\r\n    const detailGroups = this.groupByTypeAsObjects(rows, 'Details');\r\n\r\n    console.log(`Gruplar oluşturuldu: IbanHesap (${ibanGroups.length}), Details (${detailGroups.length})`);\r\n\r\n    const processedData: Array<Record<string, string>> = [];\r\n    const count = Math.max(ibanGroups.length, detailGroups.length);\r\n\r\n    for (let i = 0; i < count; i++) {\r\n      const iban = ibanGroups[i] || {};\r\n      const detail = detailGroups[i] || {};\r\n\r\n      // Önce ana verileri, sonra global verileri birleştir.\r\n      // Bu, aynı anahtar varsa (örn: TotalAmount) ana verinin öncelikli olmasını sağlar.\r\n      const mergedRecord = {\r\n        ...paramObj,\r\n        ...headerObj,\r\n        ...iban,\r\n        ...detail,\r\n      };\r\n      \r\n      // Boş veya null değerleri temizle\r\n      const cleanedRecord = this.cleanRecord(mergedRecord);\r\n      \r\n      processedData.push(cleanedRecord);\r\n    }\r\n\r\n    return {\r\n      processedData,\r\n      parametersData,\r\n      headerData,\r\n      rawRows: rows\r\n    };\r\n  }\r\n\r\n  private parseTypeKeyValueCsv(csv: string): any[] {\r\n    const lines = csv.trim().split(/\\r?\\n/);\r\n    const rows: any[] = [];\r\n    \r\n    // Başlık satırını atla (büyük/küçük harf duyarsız)\r\n    const contentLines = lines.filter(line => line.trim() && !line.toLowerCase().startsWith('type,key,value'));\r\n    \r\n    for (const line of contentLines) {\r\n      // CSV parsing'i daha güvenli yap - virgülleri value içindeki virgüllerden ayır\r\n      const parts = line.split(',');\r\n      if (parts.length < 3) {\r\n        console.warn('Hatalı CSV satırı (3 bölümden az):', line);\r\n        continue;\r\n      }\r\n      \r\n      const type = parts[0].trim();\r\n      const key = parts[1].trim();\r\n      // Değer, geri kalan her şeydir (virgül içerebilir)\r\n      const value = parts.slice(2).join(',').trim();\r\n      \r\n      // Boş type veya key'leri atla\r\n      if (type && key) {\r\n        rows.push({ type, key, value });\r\n      }\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  private extractKeyValue(rows: any[], type: string): Array<{ key: string; value: string }> {\r\n    return rows\r\n      .filter(row => row.type === type)\r\n      .map(row => ({ key: row.key, value: row.value }));\r\n  }\r\n\r\n  private toObject(pairs: Array<{ key: string; value: string }>): Record<string, string> {\r\n    return pairs.reduce((obj, item) => {\r\n      if (item.key) { // Boş anahtarları ekleme\r\n        obj[item.key] = item.value;\r\n      }\r\n      return obj;\r\n    }, {} as Record<string, string>);\r\n  }\r\n\r\n  /**\r\n   * Satırları tipine göre mantıksal gruplara ayırır.\r\n   * Bir tipin ilk anahtarı tekrarlandığında yeni bir grup başlatır.\r\n   */\r\n  private groupByTypeAsObjects(rows: any[], type: string): Array<Record<string, string>> {\r\n    const filteredRows = rows.filter(row => row.type === type);\r\n    if (filteredRows.length === 0) return [];\r\n\r\n    const groups: Array<Record<string, string>> = [];\r\n    let currentGroup: Record<string, string> = {};\r\n    \r\n    // Grubun başlangıcını belirleyen anahtarı bul (ilk satırın anahtarı)\r\n    const firstKey = filteredRows[0].key;\r\n\r\n    for (const row of filteredRows) {\r\n      // Eğer başlangıç anahtarı tekrar ederse VE mevcut grup boş değilse, yeni grup başlat\r\n      if (row.key === firstKey && Object.keys(currentGroup).length > 0) {\r\n        groups.push(currentGroup);\r\n        currentGroup = {};\r\n      }\r\n      // Anahtar boş değilse gruba ekle\r\n      if (row.key) {\r\n        currentGroup[row.key] = row.value;\r\n      }\r\n    }\r\n\r\n    // Döngüden sonra kalan son grubu da ekle\r\n    if (Object.keys(currentGroup).length > 0) {\r\n      groups.push(currentGroup);\r\n    }\r\n\r\n    return groups;\r\n  }\r\n\r\n  /**\r\n   * Record'u temizler - boş/null değerleri kaldırır.\r\n   */\r\n  private cleanRecord(record: Record<string, string>): Record<string, string> {\r\n    const cleaned: Record<string, string> = {};\r\n    \r\n    for (const [key, value] of Object.entries(record)) {\r\n      // Değerin null, undefined veya boş bir string olmadığını kontrol et\r\n      if (value != null && value.toString().trim() !== '') {\r\n        // Anahtarın da geçerli olduğundan emin ol\r\n        const cleanKey = key.trim();\r\n        if (cleanKey) {\r\n          cleaned[cleanKey] = value.toString().trim();\r\n        }\r\n      }\r\n    }\r\n    \r\n    return cleaned;\r\n  }\r\n\r\n  /**\r\n   * Anlamlı property'leri çıkarır - boş veya gereksiz key'leri filtreler\r\n   */\r\n  private extractMeaningfulProperties(data: Array<Record<string, string>>): string[] {\r\n    const allKeys = new Set<string>();\r\n    \r\n    data.forEach(row => {\r\n      Object.keys(row).forEach(key => {\r\n        // Sadece anlamlı key'leri ekle (boş olmayan)\r\n        if (key && key.trim()) {\r\n          allKeys.add(key.trim());\r\n        }\r\n      });\r\n    });\r\n    \r\n    // Anahtarları sıralayarak tutarlı bir kolon sırası elde et\r\n    return Array.from(allKeys).sort();\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}