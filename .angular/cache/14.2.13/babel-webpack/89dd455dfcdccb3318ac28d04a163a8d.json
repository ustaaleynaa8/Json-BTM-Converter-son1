{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/Json-BTM-Converter-son1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file);\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(5000), catchError(err => {\n          console.error('BTM service error:', err); // Daha spesifik error message\n\n          const errorMsg = err?.error?.message || err?.message || 'BTM servisinde beklenmeyen bir hata oluştu';\n          return throwError(() => new Error(`BTM Servisi: ${errorMsg}`));\n        }))); // CSV string boş mu kontrol et\n\n        if (!csvString || csvString.trim().length === 0) {\n          throw new Error('BTM servisinden boş CSV yanıtı alındı');\n        }\n\n        const btmResult = _this.transformBtmCsv(csvString);\n\n        if (btmResult.processedData.length > 0) {\n          console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt'); // Tablo başlıkları için sadece anlamlı anahtarları topla\n\n          const properties = _this.extractMeaningfulProperties(btmResult.processedData);\n\n          return {\n            result: btmResult.processedData,\n            properties,\n            prettyJson: btmResult.processedData,\n            via: 'btm_grouped_final',\n            parametersData: btmResult.parametersData,\n            headerData: btmResult.headerData\n          };\n        }\n\n        throw new Error('BTM dönüşümü anlamlı bir sonuç üretmedi');\n      } catch (err) {\n        console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message);\n\n        try {\n          const converter = _this.fileConverter.getConverter('xml');\n\n          if (!converter) {\n            throw new Error('XML dönüştürücü bulunamadı (local)');\n          }\n\n          const localResult = yield converter.convert(file, {});\n          return {\n            result: localResult.result,\n            properties: localResult.properties,\n            prettyJson: localResult.result,\n            via: 'local',\n            parametersData: [],\n            headerData: []\n          };\n        } catch (localErr) {\n          // Hem BTM hem local başarısız olduysa, daha detaylı hata ver\n          throw new Error(`XML işlemi başarısız - BTM: ${err.message}, Local: ${localErr.message}`);\n        }\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(new Error('Dosya okuma hatası: ' + err));\n\n      reader.readAsText(file);\n    });\n  }\n  /**\r\n   * BTM'den gelen CSV'yi gruplayarak ve birleştirerek dönüştürür.\r\n   */\n\n\n  transformBtmCsv(csv) {\n    const rows = this.parseTypeKeyValueCsv(csv);\n\n    if (rows.length === 0) {\n      return {\n        processedData: [],\n        parametersData: [],\n        headerData: [],\n        rawRows: []\n      };\n    }\n\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\n    const headerData = this.extractKeyValue(rows, 'Header');\n    const paramObj = this.toObject(parametersData);\n    const headerObj = this.toObject(headerData);\n    const ibanGroups = this.groupByTypeAsObjects(rows, 'IbanHesap');\n    const detailGroups = this.groupByTypeAsObjects(rows, 'Details');\n    console.log(`Gruplar oluşturuldu: IbanHesap (${ibanGroups.length}), Details (${detailGroups.length})`);\n    const processedData = [];\n    const count = Math.max(ibanGroups.length, detailGroups.length);\n\n    for (let i = 0; i < count; i++) {\n      const iban = ibanGroups[i] || {};\n      const detail = detailGroups[i] || {}; // Önce ana verileri, sonra global verileri birleştir.\n      // Bu, aynı anahtar varsa (örn: TotalAmount) ana verinin öncelikli olmasını sağlar.\n\n      const mergedRecord = this.cleanRecord({ ...paramObj,\n        ...headerObj,\n        ...iban,\n        ...detail\n      });\n      processedData.push(mergedRecord);\n    }\n\n    return {\n      processedData,\n      parametersData,\n      headerData,\n      rawRows: rows\n    };\n  }\n\n  parseTypeKeyValueCsv(csv) {\n    const lines = csv.trim().split(/\\r?\\n/);\n    const rows = [];\n\n    for (const line of lines) {\n      // Boş satırları ve CSV başlığını atla\n      if (!line.trim() || line.toLowerCase().startsWith('type,key,value')) continue; // CSV parsing'i daha dikkatli yap - virgülleri value içindeki virgüllerden ayır\n\n      const firstCommaIndex = line.indexOf(',');\n      const secondCommaIndex = line.indexOf(',', firstCommaIndex + 1);\n\n      if (firstCommaIndex === -1 || secondCommaIndex === -1) {\n        console.warn('Malformed CSV line:', line);\n        continue;\n      }\n\n      const type = line.substring(0, firstCommaIndex).trim();\n      const key = line.substring(firstCommaIndex + 1, secondCommaIndex).trim();\n      const value = line.substring(secondCommaIndex + 1).trim(); // Boş type veya key'leri atla\n\n      if (type && key) {\n        rows.push({\n          type,\n          key,\n          value\n        });\n      }\n    }\n\n    return rows;\n  }\n\n  extractKeyValue(rows, type) {\n    return rows.filter(row => row.type === type).map(row => ({\n      key: row.key,\n      value: row.value\n    }));\n  }\n\n  toObject(pairs) {\n    return pairs.reduce((obj, item) => ({ ...obj,\n      [item.key]: item.value\n    }), {});\n  }\n  /**\r\n   * Satırları tipine göre mantıksal gruplara ayırır.\r\n   * Bir tipin ilk anahtarı tekrarlandığında yeni bir grup başlatır.\r\n   */\n\n\n  groupByTypeAsObjects(rows, type) {\n    const filteredRows = rows.filter(row => row.type === type);\n    if (filteredRows.length === 0) return [];\n    const groups = [];\n    let currentGroup = {};\n    const firstKey = filteredRows[0].key;\n\n    for (const row of filteredRows) {\n      if (row.key === firstKey && Object.keys(currentGroup).length > 0) {\n        groups.push(currentGroup);\n        currentGroup = {};\n      }\n\n      currentGroup[row.key] = row.value;\n    }\n\n    if (Object.keys(currentGroup).length > 0) {\n      groups.push(currentGroup);\n    }\n\n    return groups;\n  }\n  /**\r\n   * Record'u temizler - boş değerleri kaldırır ve key'leri normalleştirir\r\n   */\n\n\n  cleanRecord(record) {\n    const cleaned = {};\n\n    for (const [key, value] of Object.entries(record)) {\n      // Boş veya null değerleri atla\n      if (value != null && value.toString().trim() !== '') {\n        // Key'i temizle - sayısal suffix'leri ve gereksiz karakterleri kaldır\n        const cleanKey = this.normalizeKey(key);\n\n        if (cleanKey) {\n          cleaned[cleanKey] = value.toString().trim();\n        }\n      }\n    }\n\n    return cleaned;\n  }\n  /**\r\n   * Key'leri normalleştirir - DestinationAccountNo2 -> DestinationAccountNo gibi\r\n   */\n\n\n  normalizeKey(key) {\n    if (!key) return '';\n    let normalized = key.trim(); // Sayısal suffix'leri kaldır (DestinationAccountNo2 -> DestinationAccountNo)\n\n    normalized = normalized.replace(/\\d+$/, ''); // Gereksiz karakterleri temizle\n\n    normalized = normalized.replace(/[^a-zA-Z0-9_]/g, '');\n    return normalized;\n  }\n  /**\r\n   * Anlamlı property'leri çıkarır - boş veya gereksiz key'leri filtreler\r\n   */\n\n\n  extractMeaningfulProperties(data) {\n    const allKeys = new Set();\n    data.forEach(row => {\n      Object.keys(row).forEach(key => {\n        // Sadece anlamlı key'leri ekle\n        if (key && key.length > 1 && !key.match(/^[0-9]+$/)) {\n          allKeys.add(key);\n        }\n      });\n    });\n    return Array.from(allKeys).sort();\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["catchError","throwError","firstValueFrom","timeout","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","error","errorMsg","message","Error","trim","length","btmResult","transformBtmCsv","processedData","log","properties","extractMeaningfulProperties","result","prettyJson","via","parametersData","headerData","converter","getConverter","localResult","convert","localErr","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","csv","rows","parseTypeKeyValueCsv","rawRows","extractKeyValue","paramObj","toObject","headerObj","ibanGroups","groupByTypeAsObjects","detailGroups","count","Math","max","i","iban","detail","mergedRecord","cleanRecord","push","lines","split","line","toLowerCase","startsWith","firstCommaIndex","indexOf","secondCommaIndex","warn","type","substring","key","value","filter","row","map","pairs","reduce","obj","item","filteredRows","groups","currentGroup","firstKey","Object","keys","record","cleaned","entries","toString","cleanKey","normalizeKey","normalized","replace","data","allKeys","Set","forEach","match","add","Array","from","sort","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\Json-BTM-Converter-son1\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];\r\n  properties?: string[];\r\n  prettyJson?: any;\r\n  via: string;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n}\r\n\r\nexport interface BtmTransformResult {\r\n  processedData: Array<Record<string, string>>;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n  rawRows: any[];\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(5000),\r\n          catchError(err => {\r\n            console.error('BTM service error:', err);\r\n            // Daha spesifik error message\r\n            const errorMsg = err?.error?.message || err?.message || 'BTM servisinde beklenmeyen bir hata oluştu';\r\n            return throwError(() => new Error(`BTM Servisi: ${errorMsg}`));\r\n          })\r\n        )\r\n      );\r\n\r\n      // CSV string boş mu kontrol et\r\n      if (!csvString || csvString.trim().length === 0) {\r\n        throw new Error('BTM servisinden boş CSV yanıtı alındı');\r\n      }\r\n\r\n      const btmResult = this.transformBtmCsv(csvString);\r\n\r\n      if (btmResult.processedData.length > 0) {\r\n        console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt');\r\n\r\n        // Tablo başlıkları için sadece anlamlı anahtarları topla\r\n        const properties = this.extractMeaningfulProperties(btmResult.processedData);\r\n\r\n        return {\r\n          result: btmResult.processedData,\r\n          properties,\r\n          prettyJson: btmResult.processedData,\r\n          via: 'btm_grouped_final',\r\n          parametersData: btmResult.parametersData,\r\n          headerData: btmResult.headerData\r\n        };\r\n      }\r\n\r\n      throw new Error('BTM dönüşümü anlamlı bir sonuç üretmedi');\r\n\r\n    } catch (err: any) {\r\n      console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message);\r\n      \r\n      try {\r\n        const converter = this.fileConverter.getConverter('xml');\r\n        if (!converter) {\r\n          throw new Error('XML dönüştürücü bulunamadı (local)');\r\n        }\r\n        const localResult = await converter.convert(file, {});\r\n        return {\r\n          result: localResult.result,\r\n          properties: localResult.properties,\r\n          prettyJson: localResult.result,\r\n          via: 'local',\r\n          parametersData: [],\r\n          headerData: []\r\n        };\r\n      } catch (localErr: any) {\r\n        // Hem BTM hem local başarısız olduysa, daha detaylı hata ver\r\n        throw new Error(`XML işlemi başarısız - BTM: ${err.message}, Local: ${localErr.message}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(new Error('Dosya okuma hatası: ' + err));\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * BTM'den gelen CSV'yi gruplayarak ve birleştirerek dönüştürür.\r\n   */\r\n  private transformBtmCsv(csv: string): BtmTransformResult {\r\n    const rows = this.parseTypeKeyValueCsv(csv);\r\n    if (rows.length === 0) {\r\n      return { processedData: [], parametersData: [], headerData: [], rawRows: [] };\r\n    }\r\n\r\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\r\n    const headerData = this.extractKeyValue(rows, 'Header');\r\n    const paramObj = this.toObject(parametersData);\r\n    const headerObj = this.toObject(headerData);\r\n\r\n    const ibanGroups = this.groupByTypeAsObjects(rows, 'IbanHesap');\r\n    const detailGroups = this.groupByTypeAsObjects(rows, 'Details');\r\n\r\n    console.log(`Gruplar oluşturuldu: IbanHesap (${ibanGroups.length}), Details (${detailGroups.length})`);\r\n\r\n    const processedData: Array<Record<string, string>> = [];\r\n    const count = Math.max(ibanGroups.length, detailGroups.length);\r\n\r\n    for (let i = 0; i < count; i++) {\r\n      const iban = ibanGroups[i] || {};\r\n      const detail = detailGroups[i] || {};\r\n\r\n      // Önce ana verileri, sonra global verileri birleştir.\r\n      // Bu, aynı anahtar varsa (örn: TotalAmount) ana verinin öncelikli olmasını sağlar.\r\n      const mergedRecord = this.cleanRecord({\r\n        ...paramObj,\r\n        ...headerObj,\r\n        ...iban,\r\n        ...detail,\r\n      });\r\n      \r\n      processedData.push(mergedRecord);\r\n    }\r\n\r\n    return {\r\n      processedData,\r\n      parametersData,\r\n      headerData,\r\n      rawRows: rows\r\n    };\r\n  }\r\n\r\n  private parseTypeKeyValueCsv(csv: string): any[] {\r\n    const lines = csv.trim().split(/\\r?\\n/);\r\n    const rows: any[] = [];\r\n    \r\n    for (const line of lines) {\r\n      // Boş satırları ve CSV başlığını atla\r\n      if (!line.trim() || line.toLowerCase().startsWith('type,key,value')) continue;\r\n      \r\n      // CSV parsing'i daha dikkatli yap - virgülleri value içindeki virgüllerden ayır\r\n      const firstCommaIndex = line.indexOf(',');\r\n      const secondCommaIndex = line.indexOf(',', firstCommaIndex + 1);\r\n      \r\n      if (firstCommaIndex === -1 || secondCommaIndex === -1) {\r\n        console.warn('Malformed CSV line:', line);\r\n        continue;\r\n      }\r\n      \r\n      const type = line.substring(0, firstCommaIndex).trim();\r\n      const key = line.substring(firstCommaIndex + 1, secondCommaIndex).trim();\r\n      const value = line.substring(secondCommaIndex + 1).trim();\r\n      \r\n      // Boş type veya key'leri atla\r\n      if (type && key) {\r\n        rows.push({ type, key, value });\r\n      }\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  private extractKeyValue(rows: any[], type: string): Array<{ key: string; value: string }> {\r\n    return rows\r\n      .filter(row => row.type === type)\r\n      .map(row => ({ key: row.key, value: row.value }));\r\n  }\r\n\r\n  private toObject(pairs: Array<{ key: string; value: string }>): Record<string, string> {\r\n    return pairs.reduce((obj, item) => ({ ...obj, [item.key]: item.value }), {});\r\n  }\r\n\r\n  /**\r\n   * Satırları tipine göre mantıksal gruplara ayırır.\r\n   * Bir tipin ilk anahtarı tekrarlandığında yeni bir grup başlatır.\r\n   */\r\n  private groupByTypeAsObjects(rows: any[], type: string): Array<Record<string, string>> {\r\n    const filteredRows = rows.filter(row => row.type === type);\r\n    if (filteredRows.length === 0) return [];\r\n\r\n    const groups: Array<Record<string, string>> = [];\r\n    let currentGroup: Record<string, string> = {};\r\n    \r\n    const firstKey = filteredRows[0].key;\r\n\r\n    for (const row of filteredRows) {\r\n      if (row.key === firstKey && Object.keys(currentGroup).length > 0) {\r\n        groups.push(currentGroup);\r\n        currentGroup = {};\r\n      }\r\n      currentGroup[row.key] = row.value;\r\n    }\r\n\r\n    if (Object.keys(currentGroup).length > 0) {\r\n      groups.push(currentGroup);\r\n    }\r\n\r\n    return groups;\r\n  }\r\n\r\n  /**\r\n   * Record'u temizler - boş değerleri kaldırır ve key'leri normalleştirir\r\n   */\r\n  private cleanRecord(record: Record<string, string>): Record<string, string> {\r\n    const cleaned: Record<string, string> = {};\r\n    \r\n    for (const [key, value] of Object.entries(record)) {\r\n      // Boş veya null değerleri atla\r\n      if (value != null && value.toString().trim() !== '') {\r\n        // Key'i temizle - sayısal suffix'leri ve gereksiz karakterleri kaldır\r\n        const cleanKey = this.normalizeKey(key);\r\n        if (cleanKey) {\r\n          cleaned[cleanKey] = value.toString().trim();\r\n        }\r\n      }\r\n    }\r\n    \r\n    return cleaned;\r\n  }\r\n\r\n  /**\r\n   * Key'leri normalleştirir - DestinationAccountNo2 -> DestinationAccountNo gibi\r\n   */\r\n  private normalizeKey(key: string): string {\r\n    if (!key) return '';\r\n    \r\n    let normalized = key.trim();\r\n    \r\n    // Sayısal suffix'leri kaldır (DestinationAccountNo2 -> DestinationAccountNo)\r\n    normalized = normalized.replace(/\\d+$/, '');\r\n    \r\n    // Gereksiz karakterleri temizle\r\n    normalized = normalized.replace(/[^a-zA-Z0-9_]/g, '');\r\n    \r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Anlamlı property'leri çıkarır - boş veya gereksiz key'leri filtreler\r\n   */\r\n  private extractMeaningfulProperties(data: Array<Record<string, string>>): string[] {\r\n    const allKeys = new Set<string>();\r\n    \r\n    data.forEach(row => {\r\n      Object.keys(row).forEach(key => {\r\n        // Sadece anlamlı key'leri ekle\r\n        if (key && key.length > 1 && !key.match(/^[0-9]+$/)) {\r\n          allKeys.add(key);\r\n        }\r\n      });\r\n    });\r\n    \r\n    return Array.from(allKeys).sort();\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}