{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/Json-Btm-son/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nexport class XmlFileConverterService {\n  constructor() {\n    this.defaultFieldMapping = {\n      isim: ['isim', 'ad', 'name'],\n      soyisim: ['soyisim', 'soyad', 'surname']\n    };\n  }\n\n  convert(_x) {\n    var _this = this;\n\n    return _asyncToGenerator(function* (file, options = {}) {\n      const xmlString = yield _this.readFileAsText(file);\n\n      const jsonArray = _this.parseXmlToJson(xmlString, options);\n\n      const firstRowKeys = jsonArray.length > 0 ? Object.keys(jsonArray[0]) : [];\n      return {\n        result: jsonArray,\n        properties: firstRowKeys,\n        type: 'xml'\n      };\n    }).apply(this, arguments);\n  }\n\n  parseXmlToJson(xmlString, options = {}) {\n    const parser = new DOMParser();\n    const xml = parser.parseFromString(xmlString, 'text/xml');\n    const parserError = xml.getElementsByTagName('parsererror');\n\n    if (parserError.length > 0) {\n      throw new Error('Geçersiz XML formatı: ' + parserError[0].textContent);\n    }\n\n    const root = options.rootElement ? xml.getElementsByTagName(options.rootElement)[0] : xml.documentElement;\n\n    if (!root) {\n      throw new Error(`Belirtilen root element (${options.rootElement}) bulunamadı.`);\n    }\n\n    const allChildren = Array.from(root.children);\n    const mapping = options.fieldMapping || this.defaultFieldMapping;\n    return allChildren.map(item => {\n      const obj = {};\n      Array.from(item.children).forEach(child => {\n        obj[child.tagName] = child.textContent ?? '';\n      });\n      return this.mapFieldsWithOrder(obj, mapping);\n    });\n  }\n\n  mapFieldsWithOrder(obj, fieldMapping) {\n    const mapped = {};\n    const usedFields = new Set();\n    Object.keys(obj).forEach(key => {\n      let mappedKey = key;\n\n      for (const [target, aliases] of Object.entries(fieldMapping)) {\n        if (aliases.includes(key)) {\n          mappedKey = target;\n          break;\n        }\n      }\n\n      if (!usedFields.has(mappedKey)) {\n        mapped[mappedKey] = obj[key];\n        usedFields.add(mappedKey);\n      }\n    });\n    return mapped;\n  }\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = () => reject(reader.error);\n\n      reader.readAsText(file);\n    });\n  }\n\n}\n\nXmlFileConverterService.ɵfac = function XmlFileConverterService_Factory(t) {\n  return new (t || XmlFileConverterService)();\n};\n\nXmlFileConverterService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: XmlFileConverterService,\n  factory: XmlFileConverterService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["XmlFileConverterService","constructor","isim","soyisim","convert","file","options","xmlString","readFileAsText","jsonArray","parseXmlToJson","firstRowKeys","length","Object","keys","result","properties","type","parser","DOMParser","xml","parseFromString","parserError","getElementsByTagName","Error","textContent","root","rootElement","documentElement","allChildren","Array","from","children","mapping","fieldMapping","defaultFieldMapping","map","item","obj","forEach","child","tagName","mapFieldsWithOrder","mapped","usedFields","Set","key","mappedKey","target","aliases","entries","includes","has","add","Promise","resolve","reject","reader","FileReader","onload","onerror","error","readAsText","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\Json-Btm-son\\src\\app\\services\\xml-file-converter.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { IFileConverter } from '../interfaces/ifile-converter';\r\n\r\nexport interface XmlOptions {\r\n    rootElement?: string;\r\n    fieldMapping?: { [key: string]: string[] };\r\n}\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class XmlFileConverterService implements IFileConverter {\r\n    private defaultFieldMapping: { [key: string]: string[] } = {\r\n        isim: ['isim', 'ad', 'name'],\r\n        soyisim: ['soyisim', 'soyad', 'surname']\r\n    };\r\n\r\n    async convert(file: File, options: XmlOptions = {}): Promise<{ result: any[]; properties: string[]; type: string }> {\r\n        const xmlString = await this.readFileAsText(file);\r\n        const jsonArray = this.parseXmlToJson(xmlString, options);\r\n        const firstRowKeys = jsonArray.length > 0 ? Object.keys(jsonArray[0]) : [];\r\n\r\n        return {\r\n            result: jsonArray,\r\n            properties: firstRowKeys,\r\n            type: 'xml'\r\n        };\r\n    }\r\n\r\n\r\n    private parseXmlToJson(xmlString: string, options: XmlOptions = {}): any[] {\r\n        const parser = new DOMParser();\r\n        const xml = parser.parseFromString(xmlString, 'text/xml');\r\n\r\n        const parserError = xml.getElementsByTagName('parsererror');\r\n        if (parserError.length > 0) {\r\n            throw new Error('Geçersiz XML formatı: ' + parserError[0].textContent);\r\n        }\r\n\r\n        const root = options.rootElement\r\n            ? xml.getElementsByTagName(options.rootElement)[0]\r\n            : xml.documentElement;\r\n\r\n        if (!root) {\r\n            throw new Error(`Belirtilen root element (${options.rootElement}) bulunamadı.`);\r\n        }\r\n\r\n        const allChildren = Array.from(root.children);\r\n        const mapping = options.fieldMapping || this.defaultFieldMapping;\r\n\r\n        return allChildren.map(item => {\r\n            const obj: any = {};\r\n            Array.from(item.children).forEach(child => {\r\n                obj[child.tagName] = child.textContent ?? '';\r\n            });\r\n            return this.mapFieldsWithOrder(obj, mapping);\r\n        });\r\n    }\r\n\r\n\r\n    private mapFieldsWithOrder(obj: any, fieldMapping: { [key: string]: string[] }): any {\r\n        const mapped: any = {};\r\n        const usedFields: Set<string> = new Set();\r\n\r\n        Object.keys(obj).forEach(key => {\r\n            let mappedKey = key;\r\n            for (const [target, aliases] of Object.entries(fieldMapping)) {\r\n                if (aliases.includes(key)) {\r\n                    mappedKey = target;\r\n                    break;\r\n                }\r\n            }\r\n            if (!usedFields.has(mappedKey)) {\r\n                mapped[mappedKey] = obj[key];\r\n                usedFields.add(mappedKey);\r\n            }\r\n        });\r\n        return mapped;\r\n    }\r\n\r\n    private readFileAsText(file: File): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = () => resolve(reader.result as string);\r\n            reader.onerror = () => reject(reader.error);\r\n            reader.readAsText(file);\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}