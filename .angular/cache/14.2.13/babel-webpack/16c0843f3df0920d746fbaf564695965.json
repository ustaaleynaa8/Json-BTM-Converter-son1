{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/Json-BTM-Converter-son1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { convertToUTF8 } from \"src/app/utils/encoding-maps\";\nimport * as i0 from \"@angular/core\";\nexport class CsvConverterService {\n  convertFileToJson(file, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      //dosya yukleme /donusum ıslemlerı asenkron ılerler\n      const arrayBuffer = yield file.arrayBuffer(); //fıle'ı array buffer olarak donduruyor\n\n      const csvContent = convertToUTF8(arrayBuffer, options.selectedEncoding); //dogru encodıng ıle strınge cevırıyor. bu metod encodıng mapste\n\n      return _this.parseCsvToJson(csvContent, options);\n    })();\n  }\n\n  hasPrefixAndSuffix(options) {\n    //row prefix veya suffix'e bir şey girilmiş mi diye kontrol ediyor\n    return options.rowPrefix.trim() !== \"\" || options.rowSuffix.trim() !== \"\";\n  }\n\n  quoteCharacter(options) {\n    switch (options.selectedQuoteOption) {\n      case \"single\":\n        return \"'\";\n\n      case \"double\":\n        return '\"';\n\n      case \"none\":\n      default:\n        return \"\";\n    }\n  } //quote handling enabled mı değil mi\n\n\n  isQuoteHandlingEnabled(options) {\n    return options.selectedQuoteOption !== \"none\";\n  }\n\n  parseCsvToJson(csvContent, options) {\n    let allLines; // Always start with basic row splitting based on row delimiter\n\n    if (options.selectedRowDelimiter === \"newline\") {\n      console.log(\"Using newline row delimiter\");\n      allLines = csvContent.split(/\\r?\\n/);\n    } else if (options.selectedRowDelimiter === \"carriage-return\") {\n      console.log(\"Using carriage return row delimiter\");\n      allLines = csvContent.split(/\\r/);\n    } else if (options.selectedRowDelimiter === \"crlf\") {\n      console.log(\"Using carriage return + newline row delimiter\");\n      allLines = csvContent.split(/\\r\\n/);\n    } else {\n      console.log(`Using custom row delimiter: \"${options.selectedRowDelimiter}\"`); // Handle custom row delimiter\n\n      const rowDelimiter = options.selectedRowDelimiter === \"\\t\" ? \"\\t\" : options.selectedRowDelimiter;\n      allLines = csvContent.split(rowDelimiter);\n    } // Filter out completely empty lines\n\n\n    allLines = allLines.filter(line => line.trim() !== \"\"); // If prefix/suffix are provided, separate header and data lines\n\n    if (this.hasPrefixAndSuffix(options)) {\n      console.log(`Filtering lines with prefix/suffix: \"${options.rowPrefix}\" ... \"${options.rowSuffix}\"`);\n      const headerLine = options.hasHeader ? allLines[0] : null;\n      const dataLines = allLines.slice(options.hasHeader ? 1 : 0); // Filter only data lines for prefix/suffix pattern\n\n      const filteredDataLines = dataLines.filter(line => {\n        const trimmedLine = line.trim();\n        return trimmedLine.includes(options.rowPrefix) && trimmedLine.includes(options.rowSuffix);\n      }); // Reconstruct allLines with header (if exists) + filtered data lines\n\n      allLines = headerLine ? [headerLine, ...filteredDataLines] : filteredDataLines;\n      console.log(`Found ${filteredDataLines.length} data lines matching prefix/suffix pattern`);\n    }\n\n    if (allLines.length === 0) {\n      throw new Error(\"No data found in file with current parsing settings\");\n    }\n\n    console.log(\"Raw lines:\", allLines);\n    let headers;\n    let dataLines = []; // HEADER LOGIC\n\n    if (options.hasHeader) {\n      console.log(\"Using first line as headers\");\n      let headerValues = this.parseCSVLine(allLines[0], options); // Clean prefix/suffix from header values only if the header actually contains the pattern\n\n      if (this.hasPrefixAndSuffix(options) || this.rowContainsPrefixSuffix(allLines[0], options)) {\n        headerValues = this.cleanPrefixSuffixFromRow(headerValues, options);\n      }\n\n      if (options.trimWhitespace) {\n        headerValues = headerValues.map(header => header.trim());\n      }\n\n      headers = headerValues;\n      dataLines = allLines.slice(1);\n    } else {\n      console.log(\"Generating generic column names\");\n      const firstDataRow = allLines.find(line => line.trim() !== \"\");\n\n      if (!firstDataRow) {\n        throw new Error(\"No data found in CSV file\");\n      }\n\n      let firstRowValues = this.parseCSVLine(firstDataRow, options); // Clean prefix/suffix to get accurate column count\n\n      if (this.hasPrefixAndSuffix(options)) {\n        firstRowValues = this.cleanPrefixSuffixFromRow(firstRowValues, options);\n      }\n\n      const columnCount = firstRowValues.length;\n      headers = Array.from({\n        length: columnCount\n      }, (_, idx) => `column${idx + 1}`);\n      dataLines = allLines; // Use all lines as data when no header\n    }\n\n    console.log(\"Headers:\", headers); // Convert data lines to JSON objects\n\n    const jsonArray = [];\n\n    for (let i = 0; i < dataLines.length; i++) {\n      const line = dataLines[i];\n      if (line.trim() === \"\") continue;\n\n      if (options.skipEmptyLines && this.isEmptyRow(line, options)) {\n        continue;\n      } // Parse line normally\n\n\n      let values = this.parseCSVLine(line, options);\n      console.log(`Row ${i + 1} before cleaning:`, values); // Clean prefix/suffix from first and last columns if they exist\n\n      if (this.hasPrefixAndSuffix(options)) {\n        values = this.cleanPrefixSuffixFromRow(values, options);\n        console.log(`Row ${i + 1} after cleaning:`, values);\n      }\n\n      if (values.length > headers.length) {\n        throw new Error(`Row ${i + 1} contains more columns (${values.length}) than expected (${headers.length}). Please check if your data contains unescaped quotes or delimiters.`);\n      }\n\n      while (values.length < headers.length) {\n        values.push(\"\");\n      }\n\n      const obj = {};\n      headers.forEach((header, index) => {\n        let value = values[index] || \"\";\n\n        if (options.trimWhitespace) {\n          value = value.trim();\n        }\n\n        obj[header] = value;\n      });\n      jsonArray.push(obj);\n    }\n\n    return {\n      properties: headers,\n      result: jsonArray\n    };\n  }\n  /**\r\n   * Clean prefix from first column and suffix from last column\r\n   */\n\n\n  cleanPrefixSuffixFromRow(values, options) {\n    if (values.length === 0) return values;\n    const cleanedValues = [...values];\n    console.log(`Cleaning prefix \"${options.rowPrefix}\" and suffix \"${options.rowSuffix}\" from:`, values); // Clean prefix from first column only if it actually starts with the prefix\n\n    if (options.rowPrefix.trim() !== \"\" && cleanedValues[0] && cleanedValues[0].startsWith(options.rowPrefix)) {\n      cleanedValues[0] = cleanedValues[0].substring(options.rowPrefix.length);\n    } // Clean suffix from last column only if it actually ends with the suffix\n\n\n    if (options.rowSuffix.trim() !== \"\" && cleanedValues[cleanedValues.length - 1]) {\n      const lastIndex = cleanedValues.length - 1;\n\n      if (cleanedValues[lastIndex].endsWith(options.rowSuffix)) {\n        cleanedValues[lastIndex] = cleanedValues[lastIndex].substring(0, cleanedValues[lastIndex].length - options.rowSuffix.length);\n        console.log(`Removed suffix from last column: \"${cleanedValues[lastIndex]}\"`);\n      }\n    }\n\n    console.log(`Final cleaned values:`, cleanedValues);\n    return cleanedValues;\n  }\n\n  parseCSVLine(line, options) {\n    if (!this.isQuoteHandlingEnabled(options)) {\n      return line.split(options.selectedDelimiter);\n    } // Complex parsing for quote handling\n\n\n    const result = [];\n    let current = \"\";\n    let inQuotes = false;\n    let i = 0;\n    const quoteChar = this.quoteCharacter(options);\n\n    while (i < line.length) {\n      const char = line[i];\n      const nextChar = line[i + 1];\n\n      if (char === quoteChar && !inQuotes) {\n        inQuotes = true;\n      } else if (char === quoteChar && inQuotes) {\n        if (nextChar === quoteChar) {\n          current += quoteChar;\n          i++;\n        } else {\n          inQuotes = false;\n        }\n      } else if (char === options.selectedDelimiter && !inQuotes) {\n        result.push(current);\n        current = \"\";\n      } else {\n        current += char;\n      }\n\n      i++;\n    }\n\n    result.push(current);\n    return result;\n  }\n\n  isEmptyRow(line, options) {\n    if (!this.isQuoteHandlingEnabled(options)) {\n      const values = line.split(options.selectedDelimiter);\n      const hasContent = values.some(value => {\n        const trimmed = value.trim();\n        return trimmed !== \"\" && trimmed !== '\"\"' && trimmed !== \"''\";\n      });\n      return !hasContent;\n    } else {\n      const values = this.parseCSVLine(line, options);\n      const hasContent = values.some(value => value.trim() !== \"\");\n      return !hasContent;\n    }\n  }\n  /**\r\n   * Check if a row contains the specified prefix and suffix pattern\r\n   */\n\n\n  rowContainsPrefixSuffix(line, options) {\n    if (!this.hasPrefixAndSuffix(options)) {\n      return false;\n    }\n\n    const trimmedLine = line.trim();\n    return trimmedLine.includes(options.rowPrefix) || trimmedLine.includes(options.rowSuffix);\n  }\n\n}\n\nCsvConverterService.ɵfac = function CsvConverterService_Factory(t) {\n  return new (t || CsvConverterService)();\n};\n\nCsvConverterService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: CsvConverterService,\n  factory: CsvConverterService.ɵfac,\n  providedIn: \"root\"\n});","map":{"version":3,"mappings":"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","names":["convertToUTF8","CsvConverterService","convertFileToJson","file","options","arrayBuffer","csvContent","selectedEncoding","parseCsvToJson","hasPrefixAndSuffix","rowPrefix","trim","rowSuffix","quoteCharacter","selectedQuoteOption","isQuoteHandlingEnabled","allLines","selectedRowDelimiter","console","log","split","rowDelimiter","filter","line","headerLine","hasHeader","dataLines","slice","filteredDataLines","trimmedLine","includes","length","Error","headers","headerValues","parseCSVLine","rowContainsPrefixSuffix","cleanPrefixSuffixFromRow","trimWhitespace","map","header","firstDataRow","find","firstRowValues","columnCount","Array","from","_","idx","jsonArray","i","skipEmptyLines","isEmptyRow","values","push","obj","forEach","index","value","properties","result","cleanedValues","startsWith","substring","lastIndex","endsWith","selectedDelimiter","current","inQuotes","quoteChar","char","nextChar","hasContent","some","trimmed","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\Json-BTM-Converter-son1\\src\\app\\services\\csv-converter.service.ts"],"sourcesContent":["import { Injectable } from \"@angular/core\"\nimport { convertToUTF8 } from \"src/app/utils/encoding-maps\"\n\nexport interface CsvOptions {\n  hasHeader: boolean\n  skipEmptyLines: boolean\n  selectedDelimiter: string\n  doubleQuoteWrap: boolean\n  selectedRowDelimiter: string\n  rowPrefix: string\n  rowSuffix: string\n  selectedEncoding: string\n  selectedQuoteOption: string\n  trimWhitespace: boolean\n}\n\n@Injectable({ providedIn: \"root\" })\nexport class CsvConverterService {\n  async convertFileToJson(file: File, options: CsvOptions): Promise<any> {\n    //dosya yukleme /donusum ıslemlerı asenkron ılerler\n    const arrayBuffer = await file.arrayBuffer() //fıle'ı array buffer olarak donduruyor\n    const csvContent = convertToUTF8(arrayBuffer, options.selectedEncoding) //dogru encodıng ıle strınge cevırıyor. bu metod encodıng mapste\n    return this.parseCsvToJson(csvContent, options)\n  }\n\n  hasPrefixAndSuffix(options: CsvOptions): boolean {\n    //row prefix veya suffix'e bir şey girilmiş mi diye kontrol ediyor\n    return options.rowPrefix.trim() !== \"\" || options.rowSuffix.trim() !== \"\"\n  }\n\n  quoteCharacter(options: CsvOptions): string {\n    switch (options.selectedQuoteOption) {\n      case \"single\":\n        return \"'\"\n      case \"double\":\n        return '\"'\n      case \"none\":\n      default:\n        return \"\"\n    }\n  }\n  //quote handling enabled mı değil mi\n  isQuoteHandlingEnabled(options: CsvOptions): boolean {\n    return options.selectedQuoteOption !== \"none\"\n  }\n\n\n  private parseCsvToJson(csvContent: string, options: CsvOptions): any {\n    let allLines: string[]\n\n    // Always start with basic row splitting based on row delimiter\n    if (options.selectedRowDelimiter === \"newline\") {\n      console.log(\"Using newline row delimiter\")\n      allLines = csvContent.split(/\\r?\\n/)\n    } else if (options.selectedRowDelimiter === \"carriage-return\") {\n      console.log(\"Using carriage return row delimiter\")\n      allLines = csvContent.split(/\\r/)\n    } else if (options.selectedRowDelimiter === \"crlf\") {\n      console.log(\"Using carriage return + newline row delimiter\")\n      allLines = csvContent.split(/\\r\\n/)\n    } else {\n      console.log(`Using custom row delimiter: \"${options.selectedRowDelimiter}\"`)\n      // Handle custom row delimiter\n      const rowDelimiter = options.selectedRowDelimiter === \"\\t\" ? \"\\t\" : options.selectedRowDelimiter\n      allLines = csvContent.split(rowDelimiter)\n    }\n\n    // Filter out completely empty lines\n    allLines = allLines.filter((line) => line.trim() !== \"\")\n\n    // If prefix/suffix are provided, separate header and data lines\n    if (this.hasPrefixAndSuffix(options)) {\n      console.log(`Filtering lines with prefix/suffix: \"${options.rowPrefix}\" ... \"${options.rowSuffix}\"`)\n\n      const headerLine = options.hasHeader ? allLines[0] : null\n      const dataLines = allLines.slice(options.hasHeader ? 1 : 0)\n\n      // Filter only data lines for prefix/suffix pattern\n      const filteredDataLines = dataLines.filter((line) => {\n        const trimmedLine = line.trim()\n        return trimmedLine.includes(options.rowPrefix) && trimmedLine.includes(options.rowSuffix)\n      })\n\n      // Reconstruct allLines with header (if exists) + filtered data lines\n      allLines = headerLine ? [headerLine, ...filteredDataLines] : filteredDataLines\n\n      console.log(`Found ${filteredDataLines.length} data lines matching prefix/suffix pattern`)\n    }\n\n    if (allLines.length === 0) {\n      throw new Error(\"No data found in file with current parsing settings\")\n    }\n\n    console.log(\"Raw lines:\", allLines)\n\n    let headers: string[]\n    let dataLines: string[] = []\n\n    // HEADER LOGIC\n    if (options.hasHeader) {\n      console.log(\"Using first line as headers\")\n      let headerValues = this.parseCSVLine(allLines[0], options)\n\n      // Clean prefix/suffix from header values only if the header actually contains the pattern\n      if (this.hasPrefixAndSuffix(options) || this.rowContainsPrefixSuffix(allLines[0], options)) {\n        headerValues = this.cleanPrefixSuffixFromRow(headerValues, options)\n      }\n\n      if (options.trimWhitespace) {\n        headerValues = headerValues.map((header) => header.trim())\n      }\n      headers = headerValues\n      dataLines = allLines.slice(1)\n    } else {\n      console.log(\"Generating generic column names\")\n      const firstDataRow = allLines.find((line) => line.trim() !== \"\")\n      if (!firstDataRow) {\n        throw new Error(\"No data found in CSV file\")\n      }\n      let firstRowValues = this.parseCSVLine(firstDataRow, options)\n\n      // Clean prefix/suffix to get accurate column count\n      if (this.hasPrefixAndSuffix(options)) {\n        firstRowValues = this.cleanPrefixSuffixFromRow(firstRowValues, options)\n      }\n\n      const columnCount = firstRowValues.length\n      headers = Array.from({ length: columnCount }, (_, idx) => `column${idx + 1}`)\n      dataLines = allLines // Use all lines as data when no header\n    }\n\n    console.log(\"Headers:\", headers)\n\n    // Convert data lines to JSON objects\n    const jsonArray: any[] = []\n\n    for (let i = 0; i < dataLines.length; i++) {\n      const line = dataLines[i]\n\n      if (line.trim() === \"\") continue\n\n      if (options.skipEmptyLines && this.isEmptyRow(line, options)) {\n        continue\n      }\n\n      // Parse line normally\n      let values = this.parseCSVLine(line, options)\n\n      console.log(`Row ${i + 1} before cleaning:`, values)\n\n      // Clean prefix/suffix from first and last columns if they exist\n      if (this.hasPrefixAndSuffix(options)) {\n        values = this.cleanPrefixSuffixFromRow(values, options)\n        console.log(`Row ${i + 1} after cleaning:`, values)\n      }\n\n      if (values.length > headers.length) {\n        throw new Error(\n          `Row ${i + 1} contains more columns (${values.length}) than expected (${headers.length}). Please check if your data contains unescaped quotes or delimiters.`,\n        )\n      }\n\n      while (values.length < headers.length) {\n        values.push(\"\")\n      }\n\n      const obj: any = {}\n      headers.forEach((header, index) => {\n        let value = values[index] || \"\"\n        if (options.trimWhitespace) {\n          value = value.trim()\n        }\n        obj[header] = value\n      })\n      jsonArray.push(obj)\n    }\n\n    return {\n      properties: headers,\n      result: jsonArray,\n    }\n  }\n\n  /**\n   * Clean prefix from first column and suffix from last column\n   */\n  private cleanPrefixSuffixFromRow(values: string[], options: CsvOptions): string[] {\n    if (values.length === 0) return values\n\n    const cleanedValues = [...values]\n\n    console.log(`Cleaning prefix \"${options.rowPrefix}\" and suffix \"${options.rowSuffix}\" from:`, values)\n\n    // Clean prefix from first column only if it actually starts with the prefix\n    if (options.rowPrefix.trim() !== \"\" && cleanedValues[0] && cleanedValues[0].startsWith(options.rowPrefix)) {\n      cleanedValues[0] = cleanedValues[0].substring(options.rowPrefix.length)\n    }\n\n    // Clean suffix from last column only if it actually ends with the suffix\n    if (options.rowSuffix.trim() !== \"\" && cleanedValues[cleanedValues.length - 1]) {\n      const lastIndex = cleanedValues.length - 1\n      if (cleanedValues[lastIndex].endsWith(options.rowSuffix)) {\n        cleanedValues[lastIndex] = cleanedValues[lastIndex].substring(\n          0,\n          cleanedValues[lastIndex].length - options.rowSuffix.length,\n        )\n        console.log(`Removed suffix from last column: \"${cleanedValues[lastIndex]}\"`)\n      }\n    }\n\n    console.log(`Final cleaned values:`, cleanedValues)\n    return cleanedValues\n  }\n\n  private parseCSVLine(line: string, options: CsvOptions): string[] {\n    if (!this.isQuoteHandlingEnabled(options)) {\n      return line.split(options.selectedDelimiter)\n    }\n\n    // Complex parsing for quote handling\n    const result: string[] = []\n    let current = \"\"\n    let inQuotes = false\n    let i = 0\n    const quoteChar = this.quoteCharacter(options)\n\n    while (i < line.length) {\n      const char = line[i]\n      const nextChar = line[i + 1]\n\n      if (char === quoteChar && !inQuotes) {\n        inQuotes = true\n      } else if (char === quoteChar && inQuotes) {\n        if (nextChar === quoteChar) {\n          current += quoteChar\n          i++\n        } else {\n          inQuotes = false\n        }\n      } else if (char === options.selectedDelimiter && !inQuotes) {\n        result.push(current)\n        current = \"\"\n      } else {\n        current += char\n      }\n      i++\n    }\n\n    result.push(current)\n    return result\n  }\n\n  private isEmptyRow(line: string, options: CsvOptions): boolean {\n    if (!this.isQuoteHandlingEnabled(options)) {\n      const values = line.split(options.selectedDelimiter)\n      const hasContent = values.some((value) => {\n        const trimmed = value.trim()\n        return trimmed !== \"\" && trimmed !== '\"\"' && trimmed !== \"''\"\n      })\n      return !hasContent\n    } else {\n      const values = this.parseCSVLine(line, options)\n      const hasContent = values.some((value) => value.trim() !== \"\")\n      return !hasContent\n    }\n  }\n\n  /**\n   * Check if a row contains the specified prefix and suffix pattern\n   */\n  private rowContainsPrefixSuffix(line: string, options: CsvOptions): boolean {\n    if (!this.hasPrefixAndSuffix(options)) {\n      return false\n    }\n\n    const trimmedLine = line.trim()\n    return trimmedLine.includes(options.rowPrefix) || trimmedLine.includes(options.rowSuffix)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}