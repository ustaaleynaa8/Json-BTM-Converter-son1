{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır, önce BTM'yi dener; olmazsa local parser'a düşer.\r\n   * Sonuç: tablo (flat) + opsiyonel prettyJson\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err)))); // --- CSV'yi dönüştür ---\n\n        const delimiter = _this.detectDelimiter(csvString);\n\n        const defaultOptions = {\n          hasHeader: false,\n          skipEmptyLines: true,\n          selectedDelimiter: delimiter,\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        };\n        const options = { ...(csvOptions || defaultOptions),\n          hasHeader: false,\n          selectedDelimiter: delimiter\n        };\n        const csvFile = new File([csvString], 'btm.csv', {\n          type: 'text/csv'\n        });\n        const converterResult = yield _this.csvFileConverter.convert(csvFile, options);\n        const records = converterResult.result || []; // 2) Type/Key/Value formatı algıla\n\n        let isTypeKeyValue = false;\n        let typeField = '';\n        let keyField = '';\n        let valueField = '';\n        const possibleFormats = [{\n          type: 'column1',\n          key: 'column2',\n          value: 'column3'\n        }, {\n          type: 'Type',\n          key: 'Key',\n          value: 'Value'\n        }, {\n          type: 'type',\n          key: 'key',\n          value: 'value'\n        }, {\n          type: '0',\n          key: '1',\n          value: '2'\n        } // index bazlı\n        ];\n\n        for (const format of possibleFormats) {\n          const hasType = records.length > 0 && records[0][format.type] !== undefined;\n          const hasKey = records.length > 0 && records[0][format.key] !== undefined;\n          const hasVal = records.length > 0 && records[0][format.value] !== undefined;\n          if (!hasType || !hasKey || !hasVal) continue;\n          const typeValues = new Set(['Parameters', 'Header', 'Details']);\n          const sample = records.slice(0, Math.min(10, records.length));\n          const ok = sample.some(r => typeValues.has(r[format.type]));\n\n          if (ok) {\n            isTypeKeyValue = true;\n            typeField = format.type;\n            keyField = format.key;\n            valueField = format.value;\n            break;\n          }\n        } // 3) Type/Key/Value → hedef JSON\n\n\n        if (isTypeKeyValue) {\n          // a) ortak kayıtları (Parameters + Header) topla, Details'i sırala\n          const shared = {};\n          const details = [];\n          console.log('Total records from CSV:', records.length);\n\n          for (const row of records) {\n            const t = row[typeField];\n            const k = row[keyField];\n            const v = row[valueField] ?? '';\n\n            if (t === 'Parameters' || t === 'Header') {\n              shared[k] = v;\n              console.log(`Parameter/Header: ${k} = ${v}`);\n            } else if (t === 'Details') {\n              details.push({\n                type: t,\n                key: k,\n                value: v\n              });\n\n              if (k === 'RegisterId') {\n                console.log(`Found RegisterId: ${v}`);\n              }\n            }\n          }\n\n          console.log(`Found ${Object.keys(shared).length} shared parameters and ${details.length} details records`); // b) RegisterId sınırlarına göre gruplandır\n\n          const groups = [];\n          let buf = [];\n          let currentRegisterId = '';\n          const hasRegisterId = details.some(d => d.key === 'RegisterId');\n          console.log(`Details gruplandırma stratejisi: ${hasRegisterId ? 'RegisterId ile' : 'Tek grup'}`);\n\n          if (hasRegisterId) {\n            // RegisterId'ye göre grupla\n            let detailCounter = 0;\n\n            for (const d of details) {\n              detailCounter++;\n\n              if (d.key === 'RegisterId') {\n                // RegisterId göründüğünde yeni grup başlat (önceki grup varsa kaydet)\n                if (buf.length > 0) {\n                  console.log(`Grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\n                  groups.push([...buf]);\n                  buf = [];\n                }\n\n                currentRegisterId = d.value;\n              } // Her detayı mevcut gruba ekle\n\n\n              buf.push({\n                key: d.key,\n                value: d.value\n              }); // Son kayıtta da kontrol et\n\n              if (detailCounter === details.length && buf.length > 0) {\n                console.log(`Son grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\n                groups.push([...buf]);\n              }\n            }\n          } else {\n            // RegisterId yoksa tüm detaylar tek grup\n            groups.push(details.map(d => ({\n              key: d.key,\n              value: d.value\n            })));\n            console.log('Tüm detaylar tek grupta toplandı:', details.length);\n          }\n\n          console.log(`Toplam ${groups.length} grup oluşturuldu`); // c) beklenen sabit kolon sırası\n\n          const preferredOrder = ['OrderFileId', 'ProductId', 'SubProductId', 'OperationCode', 'StatusId', 'CorporateId', 'OrderDate', 'VPUserId', 'CorporateProductId', 'OperationCodeId', 'Explanation', 'ErrorMessage', 'CorporateCode', 'DestinationBranchCode', 'SourceBranchCode', 'FormattedDate', 'MonthCode', 'TransferCurrencyCode', 'FooterTotalCount', 'RoundedAmount', 'FinalAccountNo', 'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount', 'TotalAmount', 'RegisterId']; // d) tüm muhtemel anahtarları çıkar (shared ∪ details)\n\n          const expectedKeys = new Set([...Object.keys(shared), ...details.map(d => d.key)]); // e) grupları düz satıra çevir: eksikler \"\" kalsın\n\n          const resultRows = []; // Sonuç oluşturma öncesi debug\n\n          console.log('Veri oluşturma için:', groups.length, 'grup,', expectedKeys.size, 'benzersiz alan'); // Her grup için düz obje oluştur\n\n          for (const g of groups) {\n            const row = {}; // default \"\" ver\n\n            expectedKeys.forEach(k => row[k] = ''); // ortak alanları bas\n\n            Object.entries(shared).forEach(([k, v]) => row[k] = v ?? ''); // grup detaylarını yaz\n\n            for (const {\n              key,\n              value\n            } of g) {\n              row[key] = value ?? '';\n            }\n\n            let registerIdValue = '';\n\n            for (const item of g) {\n              if (item.key === 'RegisterId') {\n                registerIdValue = item.value;\n                break;\n              }\n            }\n\n            console.log(`İşlenen grup - RegisterId: ${registerIdValue || 'YOK'}, Alan sayısı: ${Object.keys(row).length}`); // FOOTER FILTREYI KALDIR - tüm grupları dahil et\n\n            /*\r\n            // footer-only filtre: anlamlı detay yoksa at\r\n            const meaningful = ['OrderDetails','TransferAmount','TotalAmount','FinalAccountNo','DestinationIban']\r\n              .some(k => row[k] !== '');\r\n            if (!meaningful) continue;\r\n            */\n            // ErrorMessage datada \"\" kalsın (UI isterse \"-\" gösterir)\n\n            if (row['ErrorMessage'] === undefined) row['ErrorMessage'] = ''; // Tabloda - olarak gösterilmesi için boş değerleri - yap\n\n            for (const key of Object.keys(row)) {\n              if (row[key] === '' || row[key] === null || row[key] === undefined) {\n                row[key] = '-';\n              }\n            }\n\n            resultRows.push(row);\n          }\n\n          console.log(`Sonuç: ${resultRows.length} satır oluşturuldu`); // f) properties: sabit sıraya göre, sonra ekstra anahtarlar\n\n          const orderedProps = [...preferredOrder.filter(k => expectedKeys.has(k)), ...Array.from(expectedKeys).filter(k => !preferredOrder.includes(k))];\n          return {\n            result: resultRows,\n            properties: orderedProps,\n            prettyJson: resultRows,\n            via: 'btm'\n          };\n        } // 4) Düz CSV ise: tüm alanları topla ve boşları \"-\" yap (mevcut davranış)\n\n\n        const isDirectCsv = _this.checkForDirectCsvFormat(records);\n\n        if (isDirectCsv) {\n          const allFields = new Set();\n          records.forEach(r => Object.keys(r).forEach(k => allFields.add(k)));\n          const processed = records.map(r => {\n            const o = {};\n            Array.from(allFields).forEach(f => {\n              const v = r[f];\n              o[f] = v === undefined || v === null || v === '' || v === '-' ? '-' : v;\n            });\n            return o;\n          });\n          return {\n            result: processed,\n            properties: Array.from(allFields),\n            prettyJson: processed,\n            via: 'btm'\n          };\n        } // 5) Hiçbiri değilse olduğu gibi dön\n\n\n        return { ...converterResult,\n          prettyJson: converterResult.result,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 6) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        });\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /** Otomatik delimiter tespiti */\n\n\n  detectDelimiter(csvString) {\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\n    const delimiters = [',', ';', '\\t', '|'];\n    const counts = {};\n\n    for (const d of delimiters) {\n      counts[d] = 0;\n\n      for (const line of lines) {\n        let inQuotes = false;\n\n        for (let i = 0; i < line.length; i++) {\n          if (line[i] === '\"') inQuotes = !inQuotes;else if (line[i] === d && !inQuotes) counts[d]++;\n        }\n      }\n    }\n\n    let best = ',',\n        max = 0;\n\n    for (const [d, c] of Object.entries(counts)) {\n      if (c > max) {\n        max = c;\n        best = d;\n      }\n    }\n\n    return best;\n  }\n  /** BTM Type/Key/Value değilse düz CSV tespit */\n\n\n  checkForDirectCsvFormat(records) {\n    if (records.length === 0) return false;\n    const keys = Object.keys(records[0]);\n    const expectedHeaders = ['Count', 'RoundedAmount', 'OperationCode', 'ErrorMessage', 'FinalAccountNo', 'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount', 'count', 'roundedAmount', 'operationCode', 'errorMessage', 'finalAccountNo', 'destinationIban', 'totalCount', 'orderDetails', 'transferAmount', 'Amount', 'amount', 'Destination', 'destination', 'Operation', 'operation', 'Total', 'total', 'Order', 'order', 'Transfer', 'transfer', 'column1', 'column2', 'column3', 'column4', 'column5'];\n    const hasTypeKeyFormat = keys.some(k => ['Type', 'Key', 'Value', 'type', 'key', 'value'].includes(k));\n    if (hasTypeKeyFormat) return false;\n    const matching = expectedHeaders.filter(h => keys.includes(h));\n    return matching.length >= 3 || keys.length >= 5;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","delimiter","detectDelimiter","defaultOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","options","csvFile","File","type","converterResult","convert","records","result","isTypeKeyValue","typeField","keyField","valueField","possibleFormats","key","value","format","hasType","length","undefined","hasKey","hasVal","typeValues","Set","sample","slice","Math","min","ok","some","r","has","shared","details","console","log","row","t","k","v","push","Object","keys","groups","buf","currentRegisterId","hasRegisterId","d","detailCounter","map","preferredOrder","expectedKeys","resultRows","size","g","forEach","entries","registerIdValue","item","orderedProps","filter","Array","from","includes","properties","prettyJson","via","isDirectCsv","checkForDirectCsvFormat","allFields","add","processed","o","f","_btmErr","converter","getConverter","Error","localResult","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","lines","trim","split","delimiters","counts","line","inQuotes","i","best","max","c","expectedHeaders","hasTypeKeyFormat","matching","h","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];         // flat tablo datası\r\n  properties: string[];  // tablo başlıkları\r\n  prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n  via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır, önce BTM'yi dener; olmazsa local parser'a düşer.\r\n   * Sonuç: tablo (flat) + opsiyonel prettyJson\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    // 1) BTM'yi dene (2 sn timeout)\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(2000),\r\n          catchError(err => throwError(() => err))\r\n        )\r\n      );\r\n\r\n      // --- CSV'yi dönüştür ---\r\n      const delimiter = this.detectDelimiter(csvString);\r\n      const defaultOptions: CsvOptions = {\r\n        hasHeader: false,                  // BTM Type/Key/Value kolonları header'sız gelir\r\n        skipEmptyLines: true,\r\n        selectedDelimiter: delimiter,\r\n        doubleQuoteWrap: false,\r\n        selectedRowDelimiter: 'newline',\r\n        rowPrefix: '',\r\n        rowSuffix: '',\r\n        selectedEncoding: 'utf-8',\r\n        selectedQuoteOption: 'none',\r\n        trimWhitespace: true,\r\n      };\r\n      const options: CsvOptions = { ...(csvOptions || defaultOptions), hasHeader: false, selectedDelimiter: delimiter };\r\n\r\n      const csvFile = new File([csvString], 'btm.csv', { type: 'text/csv' });\r\n      const converterResult = await this.csvFileConverter.convert(csvFile, options);\r\n\r\n      const records: Array<Record<string, any>> = converterResult.result || [];\r\n\r\n      // 2) Type/Key/Value formatı algıla\r\n      let isTypeKeyValue = false;\r\n      let typeField = '';\r\n      let keyField = '';\r\n      let valueField = '';\r\n\r\n      const possibleFormats = [\r\n        { type: 'column1', key: 'column2', value: 'column3' }, // header:false\r\n        { type: 'Type', key: 'Key', value: 'Value' },          // header:true\r\n        { type: 'type', key: 'key', value: 'value' },          // header:true (lower)\r\n        { type: '0', key: '1', value: '2' }                    // index bazlı\r\n      ];\r\n\r\n      for (const format of possibleFormats) {\r\n        const hasType = records.length > 0 && records[0][format.type] !== undefined;\r\n        const hasKey  = records.length > 0 && records[0][format.key]  !== undefined;\r\n        const hasVal  = records.length > 0 && records[0][format.value]!== undefined;\r\n        if (!hasType || !hasKey || !hasVal) continue;\r\n\r\n        const typeValues = new Set(['Parameters', 'Header', 'Details']);\r\n        const sample = records.slice(0, Math.min(10, records.length));\r\n        const ok = sample.some(r => typeValues.has(r[format.type]));\r\n        if (ok) {\r\n          isTypeKeyValue = true;\r\n          typeField = format.type;\r\n          keyField = format.key;\r\n          valueField = format.value;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // 3) Type/Key/Value → hedef JSON\r\n      if (isTypeKeyValue) {\r\n        // a) ortak kayıtları (Parameters + Header) topla, Details'i sırala\r\n        const shared: Record<string, string> = {};\r\n        const details: Array<{ type: string; key: string; value: string }> = [];\r\n\r\n        console.log('Total records from CSV:', records.length);\r\n        \r\n        for (const row of records) {\r\n          const t = row[typeField];\r\n          const k = row[keyField];\r\n          const v = (row[valueField] ?? '') as string;\r\n\r\n          if (t === 'Parameters' || t === 'Header') {\r\n            shared[k] = v;\r\n            console.log(`Parameter/Header: ${k} = ${v}`);\r\n          } else if (t === 'Details') {\r\n            details.push({ type: t, key: k, value: v });\r\n            if (k === 'RegisterId') {\r\n              console.log(`Found RegisterId: ${v}`);\r\n            }\r\n          }\r\n        }\r\n        \r\n        console.log(`Found ${Object.keys(shared).length} shared parameters and ${details.length} details records`);\r\n\r\n        // b) RegisterId sınırlarına göre gruplandır\r\n        const groups: Array<Array<{ key: string; value: string }>> = [];\r\n        let buf: Array<{ key: string; value: string }> = [];\r\n        let currentRegisterId = '';\r\n\r\n        const hasRegisterId = details.some(d => d.key === 'RegisterId');\r\n        \r\n        console.log(`Details gruplandırma stratejisi: ${hasRegisterId ? 'RegisterId ile' : 'Tek grup'}`);\r\n        \r\n        if (hasRegisterId) {\r\n          // RegisterId'ye göre grupla\r\n          let detailCounter = 0;\r\n          \r\n          for (const d of details) {\r\n            detailCounter++;\r\n            \r\n            if (d.key === 'RegisterId') {\r\n              // RegisterId göründüğünde yeni grup başlat (önceki grup varsa kaydet)\r\n              if (buf.length > 0) {\r\n                console.log(`Grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\r\n                groups.push([...buf]);\r\n                buf = [];\r\n              }\r\n              currentRegisterId = d.value;\r\n            }\r\n            \r\n            // Her detayı mevcut gruba ekle\r\n            buf.push({ key: d.key, value: d.value });\r\n            \r\n            // Son kayıtta da kontrol et\r\n            if (detailCounter === details.length && buf.length > 0) {\r\n              console.log(`Son grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\r\n              groups.push([...buf]);\r\n            }\r\n          }\r\n          \r\n        } else {\r\n          // RegisterId yoksa tüm detaylar tek grup\r\n          groups.push(details.map(d => ({ key: d.key, value: d.value })));\r\n          console.log('Tüm detaylar tek grupta toplandı:', details.length);\r\n        }\r\n        \r\n        console.log(`Toplam ${groups.length} grup oluşturuldu`);\r\n\r\n        // c) beklenen sabit kolon sırası\r\n        const preferredOrder = [\r\n          'OrderFileId','ProductId','SubProductId','OperationCode','StatusId',\r\n          'CorporateId','OrderDate','VPUserId','CorporateProductId','OperationCodeId',\r\n          'Explanation','ErrorMessage','CorporateCode','DestinationBranchCode','SourceBranchCode',\r\n          'FormattedDate','MonthCode','TransferCurrencyCode','FooterTotalCount','RoundedAmount',\r\n          'FinalAccountNo','DestinationIban','TotalCount','OrderDetails','TransferAmount',\r\n          'TotalAmount','RegisterId'\r\n        ];\r\n\r\n        // d) tüm muhtemel anahtarları çıkar (shared ∪ details)\r\n        const expectedKeys = new Set<string>([\r\n          ...Object.keys(shared),\r\n          ...details.map(d => d.key),\r\n        ]);\r\n\r\n        // e) grupları düz satıra çevir: eksikler \"\" kalsın\r\n        const resultRows: Record<string, any>[] = [];\r\n        \r\n        // Sonuç oluşturma öncesi debug\r\n        console.log('Veri oluşturma için:', groups.length, 'grup,', expectedKeys.size, 'benzersiz alan');\r\n        \r\n        // Her grup için düz obje oluştur\r\n        for (const g of groups) {\r\n          const row: Record<string, any> = {};\r\n          \r\n          // default \"\" ver\r\n          expectedKeys.forEach(k => row[k] = '');\r\n\r\n          // ortak alanları bas\r\n          Object.entries(shared).forEach(([k, v]) => row[k] = (v ?? ''));\r\n\r\n          // grup detaylarını yaz\r\n          for (const { key, value } of g) {\r\n            row[key] = (value ?? '');\r\n          }\r\n          \r\n          let registerIdValue = '';\r\n          for (const item of g) {\r\n            if (item.key === 'RegisterId') {\r\n              registerIdValue = item.value;\r\n              break;\r\n            }\r\n          }\r\n\r\n          console.log(`İşlenen grup - RegisterId: ${registerIdValue || 'YOK'}, Alan sayısı: ${Object.keys(row).length}`);\r\n\r\n          // FOOTER FILTREYI KALDIR - tüm grupları dahil et\r\n          /* \r\n          // footer-only filtre: anlamlı detay yoksa at\r\n          const meaningful = ['OrderDetails','TransferAmount','TotalAmount','FinalAccountNo','DestinationIban']\r\n            .some(k => row[k] !== '');\r\n          if (!meaningful) continue;\r\n          */\r\n\r\n          // ErrorMessage datada \"\" kalsın (UI isterse \"-\" gösterir)\r\n          if (row['ErrorMessage'] === undefined) row['ErrorMessage'] = '';\r\n\r\n          // Tabloda - olarak gösterilmesi için boş değerleri - yap\r\n          for (const key of Object.keys(row)) {\r\n            if (row[key] === '' || row[key] === null || row[key] === undefined) {\r\n              row[key] = '-';\r\n            }\r\n          }\r\n\r\n          resultRows.push(row);\r\n        }\r\n        \r\n        console.log(`Sonuç: ${resultRows.length} satır oluşturuldu`);\r\n\r\n        // f) properties: sabit sıraya göre, sonra ekstra anahtarlar\r\n        const orderedProps = [\r\n          ...preferredOrder.filter(k => expectedKeys.has(k)),\r\n          ...Array.from(expectedKeys).filter(k => !preferredOrder.includes(k)),\r\n        ];\r\n\r\n        return {\r\n          result: resultRows,\r\n          properties: orderedProps,\r\n          prettyJson: resultRows,\r\n          via: 'btm',\r\n        };\r\n      }\r\n\r\n      // 4) Düz CSV ise: tüm alanları topla ve boşları \"-\" yap (mevcut davranış)\r\n      const isDirectCsv = this.checkForDirectCsvFormat(records);\r\n      if (isDirectCsv) {\r\n        const allFields = new Set<string>();\r\n        records.forEach(r => Object.keys(r).forEach(k => allFields.add(k)));\r\n\r\n        const processed = records.map(r => {\r\n          const o: Record<string, any> = {};\r\n          Array.from(allFields).forEach(f => {\r\n            const v = r[f];\r\n            o[f] = (v === undefined || v === null || v === '' || v === '-') ? '-' : v;\r\n          });\r\n          return o;\r\n        });\r\n\r\n        return {\r\n          result: processed,\r\n          properties: Array.from(allFields),\r\n          prettyJson: processed,\r\n          via: 'btm',\r\n        };\r\n      }\r\n\r\n      // 5) Hiçbiri değilse olduğu gibi dön\r\n      return {\r\n        ...converterResult,\r\n        prettyJson: converterResult.result,\r\n        via: 'btm',\r\n      };\r\n    } catch (_btmErr) {\r\n      // 6) BTM başarısızsa local converter'a düş\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n      const localResult = await converter.convert(file, {\r\n        // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n      });\r\n\r\n      return { ...localResult, via: 'local' };\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /** Otomatik delimiter tespiti */\r\n  private detectDelimiter(csvString: string): string {\r\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\r\n    const delimiters = [',', ';', '\\t', '|'];\r\n    const counts: { [key: string]: number } = {};\r\n\r\n    for (const d of delimiters) {\r\n      counts[d] = 0;\r\n      for (const line of lines) {\r\n        let inQuotes = false;\r\n        for (let i = 0; i < line.length; i++) {\r\n          if (line[i] === '\"') inQuotes = !inQuotes;\r\n          else if (line[i] === d && !inQuotes) counts[d]++;\r\n        }\r\n      }\r\n    }\r\n\r\n    let best = ',', max = 0;\r\n    for (const [d, c] of Object.entries(counts)) {\r\n      if (c > max) { max = c; best = d; }\r\n    }\r\n    return best;\r\n  }\r\n\r\n  /** BTM Type/Key/Value değilse düz CSV tespit */\r\n  private checkForDirectCsvFormat(records: Array<Record<string, any>>): boolean {\r\n    if (records.length === 0) return false;\r\n    const keys = Object.keys(records[0]);\r\n\r\n    const expectedHeaders = [\r\n      'Count','RoundedAmount','OperationCode','ErrorMessage','FinalAccountNo',\r\n      'DestinationIban','TotalCount','OrderDetails','TransferAmount',\r\n      'count','roundedAmount','operationCode','errorMessage','finalAccountNo',\r\n      'destinationIban','totalCount','orderDetails','transferAmount',\r\n      'Amount','amount','Destination','destination','Operation','operation',\r\n      'Total','total','Order','order','Transfer','transfer',\r\n      'column1','column2','column3','column4','column5'\r\n    ];\r\n\r\n    const hasTypeKeyFormat = keys.some(k => ['Type','Key','Value','type','key','value'].includes(k));\r\n    if (hasTypeKeyFormat) return false;\r\n\r\n    const matching = expectedHeaders.filter(h => keys.includes(h));\r\n    return matching.length >= 3 || keys.length >= 5;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}