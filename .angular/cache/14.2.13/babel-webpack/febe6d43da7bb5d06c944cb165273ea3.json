{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (ör. 2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err)))); // CSV'yi HİÇ İŞLEMEDEN CSV converter'a ver\n\n        const delimiter = _this.detectDelimiter(csvString); // istersen bunu da kaldırabiliriz\n\n\n        const defaultOptions = {\n          hasHeader: false,\n          skipEmptyLines: true,\n          selectedDelimiter: delimiter,\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        };\n        const options = { ...(csvOptions ?? defaultOptions),\n          selectedDelimiter: delimiter\n        };\n        const csvFile = new File([csvString], 'btm.csv', {\n          type: 'text/csv'\n        });\n        const converterResult = yield _this.csvFileConverter.convert(csvFile, options);\n        return { ...converterResult,\n          prettyJson: converterResult.result,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 2) BTM başarısızsa local XML converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) {\n          throw new Error('XML dönüştürücü bulunamadı (local).');\n        }\n\n        const localResult = yield converter.convert(file, {// UI'dan parametre gelirse burada forward edebilirsin\n        });\n        return { ...localResult,\n          prettyJson: localResult.result,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /** Basit delimiter tespiti (istersen CsvFileConverterService'e de devredebiliriz) */\n\n\n  detectDelimiter(csvString) {\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\n    const delimiters = [',', ';', '\\t', '|'];\n    const counts = {};\n\n    for (const d of delimiters) {\n      counts[d] = 0;\n\n      for (const line of lines) {\n        let inQuotes = false;\n\n        for (let i = 0; i < line.length; i++) {\n          if (line[i] === '\"') inQuotes = !inQuotes;else if (line[i] === d && !inQuotes) counts[d]++;\n        }\n      }\n    }\n\n    let best = ',',\n        max = 0;\n\n    for (const [d, c] of Object.entries(counts)) {\n      if (c > max) {\n        max = c;\n        best = d;\n      }\n    }\n\n    return best;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","delimiter","detectDelimiter","defaultOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","options","csvFile","File","type","converterResult","convert","prettyJson","result","via","_btmErr","converter","getConverter","Error","localResult","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","lines","trim","split","slice","delimiters","counts","d","line","inQuotes","i","length","best","max","c","Object","entries","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];         // flat tablo datası\r\n  properties: string[];  // tablo başlıkları\r\n  prettyJson?: any;      // CSV converter ne üretiyorsa aynı\r\n  via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    // 1) BTM'yi dene (ör. 2 sn timeout)\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(2000),\r\n          catchError(err => throwError(() => err))\r\n        )\r\n      );\r\n\r\n      // CSV'yi HİÇ İŞLEMEDEN CSV converter'a ver\r\n      const delimiter = this.detectDelimiter(csvString); // istersen bunu da kaldırabiliriz\r\n      const defaultOptions: CsvOptions = {\r\n        hasHeader: false,                 // BTM çıktısı çoğu zaman header'sız geliyor\r\n        skipEmptyLines: true,\r\n        selectedDelimiter: delimiter,\r\n        doubleQuoteWrap: false,\r\n        selectedRowDelimiter: 'newline',\r\n        rowPrefix: '',\r\n        rowSuffix: '',\r\n        selectedEncoding: 'utf-8',\r\n        selectedQuoteOption: 'none',\r\n        trimWhitespace: true,\r\n      };\r\n      const options: CsvOptions = { ...(csvOptions ?? defaultOptions), selectedDelimiter: delimiter };\r\n\r\n      const csvFile = new File([csvString], 'btm.csv', { type: 'text/csv' });\r\n      const converterResult = await this.csvFileConverter.convert(csvFile, options);\r\n\r\n      return {\r\n        ...converterResult,\r\n        prettyJson: converterResult.result,\r\n        via: 'btm',\r\n      };\r\n    } catch (_btmErr) {\r\n      // 2) BTM başarısızsa local XML converter'a düş\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) {\r\n        throw new Error('XML dönüştürücü bulunamadı (local).');\r\n      }\r\n\r\n      const localResult = await converter.convert(file, {\r\n        // UI'dan parametre gelirse burada forward edebilirsin\r\n      });\r\n\r\n      return {\r\n        ...localResult,\r\n        prettyJson: localResult.result,\r\n        via: 'local',\r\n      };\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /** Basit delimiter tespiti (istersen CsvFileConverterService'e de devredebiliriz) */\r\n  private detectDelimiter(csvString: string): string {\r\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\r\n    const delimiters = [',', ';', '\\t', '|'];\r\n    const counts: Record<string, number> = {};\r\n\r\n    for (const d of delimiters) {\r\n      counts[d] = 0;\r\n      for (const line of lines) {\r\n        let inQuotes = false;\r\n        for (let i = 0; i < line.length; i++) {\r\n          if (line[i] === '\"') inQuotes = !inQuotes;\r\n          else if (line[i] === d && !inQuotes) counts[d]++;\r\n        }\r\n      }\r\n    }\r\n\r\n    let best = ',', max = 0;\r\n    for (const [d, c] of Object.entries(counts)) {\r\n      if (c > max) { max = c; best = d; }\r\n    }\r\n    return best;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}