{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır, önce BTM'yi dener; olmazsa local parser'a düşer.\r\n   * Sonuç: tablo (flat) + opsiyonel prettyJson\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err)))); // --- CSV'yi dönüştür ---\n\n        const delimiter = _this.detectDelimiter(csvString);\n\n        const defaultOptions = {\n          hasHeader: false,\n          skipEmptyLines: true,\n          selectedDelimiter: delimiter,\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        };\n        const options = { ...(csvOptions || defaultOptions),\n          hasHeader: false,\n          selectedDelimiter: delimiter\n        };\n        const csvFile = new File([csvString], 'btm.csv', {\n          type: 'text/csv'\n        });\n        const converterResult = yield _this.csvFileConverter.convert(csvFile, options);\n        const records = converterResult.result || []; // 2) Type/Key/Value formatı algıla\n\n        let isTypeKeyValue = false;\n        let typeField = '';\n        let keyField = '';\n        let valueField = '';\n        console.log('CSV dönüşüm sonucu records:', records.length);\n\n        if (records.length > 0) {\n          console.log('İlk kayıt anahtarları:', Object.keys(records[0]));\n          console.log('İlk kayıt değerleri:', Object.values(records[0]));\n        }\n\n        const possibleFormats = [{\n          type: 'column1',\n          key: 'column2',\n          value: 'column3'\n        }, {\n          type: 'Type',\n          key: 'Key',\n          value: 'Value'\n        }, {\n          type: 'type',\n          key: 'key',\n          value: 'value'\n        }, {\n          type: '0',\n          key: '1',\n          value: '2'\n        } // index bazlı\n        ];\n\n        for (const format of possibleFormats) {\n          const hasType = records.length > 0 && records[0][format.type] !== undefined;\n          const hasKey = records.length > 0 && records[0][format.key] !== undefined;\n          const hasVal = records.length > 0 && records[0][format.value] !== undefined;\n\n          if (!hasType || !hasKey || !hasVal) {\n            console.log(`Format kontrol (${format.type},${format.key},${format.value}): Eksik alan`);\n            continue;\n          }\n\n          const typeValues = new Set(['Parameters', 'Header', 'Details']);\n          const sample = records.slice(0, Math.min(10, records.length)); // Type alanında beklenen değerlerin olup olmadığını kontrol et\n\n          const matchingRecords = sample.filter(r => typeValues.has(r[format.type]));\n          console.log(`Format kontrol (${format.type},${format.key},${format.value}): ${matchingRecords.length} eşleşen kayıt`);\n\n          if (matchingRecords.length > 0) {\n            isTypeKeyValue = true;\n            typeField = format.type;\n            keyField = format.key;\n            valueField = format.value;\n            console.log(`Type/Key/Value format tespit edildi: ${typeField}/${keyField}/${valueField}`);\n            break;\n          }\n        } // CSV içeriğinin ilk 5 satırını incele\n\n\n        console.log('CSV içeriği ilk 5 satır:');\n        const csvLines = csvString.split('\\n').slice(0, 5);\n        csvLines.forEach((line, i) => console.log(`Satır ${i + 1}: ${line}`)); // 3) Type/Key/Value → hedef JSON\n\n        if (isTypeKeyValue) {\n          // a) ortak kayıtları (Parameters + Header) topla, Details'i sırala\n          const shared = {};\n          const details = [];\n          console.log('Total records from CSV:', records.length);\n\n          for (const row of records) {\n            const t = row[typeField];\n            const k = row[keyField];\n            const v = row[valueField] ?? '';\n\n            if (t === 'Parameters' || t === 'Header') {\n              shared[k] = v;\n              console.log(`Parameter/Header: ${k} = ${v}`);\n            } else if (t === 'Details') {\n              details.push({\n                type: t,\n                key: k,\n                value: v\n              });\n\n              if (k === 'RegisterId') {\n                console.log(`Found RegisterId: ${v}`);\n              }\n            }\n          }\n\n          console.log(`Found ${Object.keys(shared).length} shared parameters and ${details.length} details records`); // b) RegisterId sınırlarına göre gruplandır\n\n          const groups = [];\n          let buf = [];\n          let currentRegisterId = '';\n          const hasRegisterId = details.some(d => d.key === 'RegisterId');\n          console.log(`Details gruplandırma stratejisi: ${hasRegisterId ? 'RegisterId ile' : 'Tek grup'}`);\n\n          if (hasRegisterId) {\n            // RegisterId'ye göre grupla\n            let detailCounter = 0;\n\n            for (const d of details) {\n              detailCounter++;\n\n              if (d.key === 'RegisterId') {\n                // RegisterId göründüğünde yeni grup başlat (önceki grup varsa kaydet)\n                if (buf.length > 0) {\n                  console.log(`Grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\n                  groups.push([...buf]);\n                  buf = [];\n                }\n\n                currentRegisterId = d.value;\n              } // Her detayı mevcut gruba ekle\n\n\n              buf.push({\n                key: d.key,\n                value: d.value\n              }); // Son kayıtta da kontrol et\n\n              if (detailCounter === details.length && buf.length > 0) {\n                console.log(`Son grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\n                groups.push([...buf]);\n              }\n            }\n          } else {\n            // RegisterId yoksa tüm detaylar tek grup\n            groups.push(details.map(d => ({\n              key: d.key,\n              value: d.value\n            })));\n            console.log('Tüm detaylar tek grupta toplandı:', details.length);\n          }\n\n          console.log(`Toplam ${groups.length} grup oluşturuldu`); // c) beklenen sabit kolon sırası\n\n          const preferredOrder = ['OrderFileId', 'ProductId', 'SubProductId', 'OperationCode', 'StatusId', 'CorporateId', 'OrderDate', 'VPUserId', 'CorporateProductId', 'OperationCodeId', 'Explanation', 'ErrorMessage', 'CorporateCode', 'DestinationBranchCode', 'SourceBranchCode', 'FormattedDate', 'MonthCode', 'TransferCurrencyCode', 'FooterTotalCount', 'RoundedAmount', 'FinalAccountNo', 'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount', 'TotalAmount', 'RegisterId']; // d) tüm muhtemel anahtarları çıkar (shared ∪ details)\n\n          const expectedKeys = new Set([...Object.keys(shared), ...details.map(d => d.key)]); // e) grupları düz satıra çevir: eksikler \"\" kalsın\n\n          const resultRows = []; // Sonuç oluşturma öncesi debug\n\n          console.log('Veri oluşturma için:', groups.length, 'grup,', expectedKeys.size, 'benzersiz alan'); // Her grup için düz obje oluştur\n\n          for (const g of groups) {\n            const row = {}; // default \"\" ver\n\n            expectedKeys.forEach(k => row[k] = ''); // ortak alanları bas\n\n            Object.entries(shared).forEach(([k, v]) => row[k] = v ?? ''); // grup detaylarını yaz\n\n            for (const {\n              key,\n              value\n            } of g) {\n              row[key] = value ?? '';\n            }\n\n            let registerIdValue = '';\n\n            for (const item of g) {\n              if (item.key === 'RegisterId') {\n                registerIdValue = item.value;\n                break;\n              }\n            }\n\n            console.log(`İşlenen grup - RegisterId: ${registerIdValue || 'YOK'}, Alan sayısı: ${Object.keys(row).length}`); // FOOTER FILTREYI KALDIR - tüm grupları dahil et\n\n            /*\r\n            // footer-only filtre: anlamlı detay yoksa at\r\n            const meaningful = ['OrderDetails','TransferAmount','TotalAmount','FinalAccountNo','DestinationIban']\r\n              .some(k => row[k] !== '');\r\n            if (!meaningful) continue;\r\n            */\n            // ErrorMessage datada \"\" kalsın (UI isterse \"-\" gösterir)\n\n            if (row['ErrorMessage'] === undefined) row['ErrorMessage'] = ''; // Tabloda - olarak gösterilmesi için boş değerleri - yap\n\n            for (const key of Object.keys(row)) {\n              if (row[key] === '' || row[key] === null || row[key] === undefined) {\n                row[key] = '-';\n              }\n            }\n\n            resultRows.push(row);\n          }\n\n          console.log(`Sonuç: ${resultRows.length} satır oluşturuldu`); // f) properties: sabit sıraya göre, sonra ekstra anahtarlar\n\n          const orderedProps = [...preferredOrder.filter(k => expectedKeys.has(k)), ...Array.from(expectedKeys).filter(k => !preferredOrder.includes(k))];\n          return {\n            result: resultRows,\n            properties: orderedProps,\n            prettyJson: resultRows,\n            via: 'btm'\n          };\n        } // 4) Düz CSV ise: tüm alanları topla ve boşları \"-\" yap (mevcut davranış)\n\n\n        const isDirectCsv = _this.checkForDirectCsvFormat(records);\n\n        if (isDirectCsv) {\n          console.log('Düz CSV formatı algılandı, standart işleme yapılıyor'); // Tüm olası alanları topla\n\n          const allFields = new Set();\n          records.forEach(r => Object.keys(r).forEach(k => allFields.add(k)));\n          console.log('Bulunan tüm alanlar:', Array.from(allFields)); // Beklediğimiz sütun adları - bunların olup olmadığını kontrol et\n\n          const expectedColumns = ['Count', 'RoundedAmount', 'OperationCode', 'ErrorMessage', 'FinalAccountNo', 'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount'];\n          const missingColumns = expectedColumns.filter(col => !allFields.has(col));\n\n          if (missingColumns.length > 0) {\n            console.log('UYARI: Beklenen bazı sütunlar eksik:', missingColumns);\n          } // Her kaydı işle\n\n\n          const processed = records.map(r => {\n            const o = {}; // Tüm olası alanları her kayda ekle (eksik alanlar - olsun)\n\n            Array.from(allFields).forEach(f => {\n              const v = r[f];\n              o[f] = v === undefined || v === null || v === '' || v === '-' ? '-' : v;\n            });\n            return o;\n          });\n          console.log(`İşlenen kayıt sayısı: ${processed.length}`);\n\n          if (processed.length > 0) {\n            console.log('İlk işlenen kayıt örneği:', processed[0]);\n          }\n\n          return {\n            result: processed,\n            properties: Array.from(allFields),\n            prettyJson: processed,\n            via: 'btm'\n          };\n        } // 5) Hiçbiri değilse olduğu gibi dön\n\n\n        return { ...converterResult,\n          prettyJson: converterResult.result,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 6) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        });\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /** Otomatik delimiter tespiti */\n\n\n  detectDelimiter(csvString) {\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\n    const delimiters = [',', ';', '\\t', '|'];\n    const counts = {};\n\n    for (const d of delimiters) {\n      counts[d] = 0;\n\n      for (const line of lines) {\n        let inQuotes = false;\n\n        for (let i = 0; i < line.length; i++) {\n          if (line[i] === '\"') inQuotes = !inQuotes;else if (line[i] === d && !inQuotes) counts[d]++;\n        }\n      }\n    }\n\n    let best = ',',\n        max = 0;\n\n    for (const [d, c] of Object.entries(counts)) {\n      if (c > max) {\n        max = c;\n        best = d;\n      }\n    }\n\n    return best;\n  }\n  /** BTM Type/Key/Value değilse düz CSV tespit */\n\n\n  checkForDirectCsvFormat(records) {\n    if (records.length === 0) {\n      console.log('CSV kayıt yok, format kontrolü yapılamaz');\n      return false;\n    }\n\n    const keys = Object.keys(records[0]);\n    console.log('Format kontrolü için ilk kayıt anahtarları:', keys);\n    const expectedHeaders = ['Count', 'RoundedAmount', 'OperationCode', 'ErrorMessage', 'FinalAccountNo', 'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount', 'count', 'roundedAmount', 'operationCode', 'errorMessage', 'finalAccountNo', 'destinationIban', 'totalCount', 'orderDetails', 'transferAmount', 'Amount', 'amount', 'Destination', 'destination', 'Operation', 'operation', 'Total', 'total', 'Order', 'order', 'Transfer', 'transfer', 'column1', 'column2', 'column3', 'column4', 'column5']; // Type/Key/Value formatı kontrolü - bu formatsa false döndür\n\n    const typeKeyFields = ['Type', 'Key', 'Value', 'type', 'key', 'value'];\n    const matchingTypeKeyFields = typeKeyFields.filter(k => keys.includes(k));\n\n    if (matchingTypeKeyFields.length >= 2) {\n      console.log('Type/Key/Value formatı tespit edildi, düz CSV olarak işlenmeyecek');\n      return false;\n    } // Düz CSV formatını kontrol et\n\n\n    const matchingHeaders = expectedHeaders.filter(h => keys.includes(h));\n    console.log(`${matchingHeaders.length} beklenen başlık eşleşti:`, matchingHeaders); // Daha fazla değer görüntüle\n\n    if (records.length > 0) {\n      const sampleValues = Object.values(records[0]);\n      console.log('İlk kayıt değerleri:', sampleValues);\n    } // En az 3 başlık eşleşiyor veya en az 5 alan varsa düz CSV kabul et\n\n\n    const isDirectCsv = matchingHeaders.length >= 3 || keys.length >= 5;\n    console.log(`Düz CSV formatı sonucu: ${isDirectCsv ? 'EVET' : 'HAYIR'}`);\n    return isDirectCsv;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","delimiter","detectDelimiter","defaultOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","options","csvFile","File","type","converterResult","convert","records","result","isTypeKeyValue","typeField","keyField","valueField","console","log","length","Object","keys","values","possibleFormats","key","value","format","hasType","undefined","hasKey","hasVal","typeValues","Set","sample","slice","Math","min","matchingRecords","filter","r","has","csvLines","split","forEach","line","i","shared","details","row","t","k","v","push","groups","buf","currentRegisterId","hasRegisterId","some","d","detailCounter","map","preferredOrder","expectedKeys","resultRows","size","g","entries","registerIdValue","item","orderedProps","Array","from","includes","properties","prettyJson","via","isDirectCsv","checkForDirectCsvFormat","allFields","add","expectedColumns","missingColumns","col","processed","o","f","_btmErr","converter","getConverter","Error","localResult","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","lines","trim","delimiters","counts","inQuotes","best","max","c","expectedHeaders","typeKeyFields","matchingTypeKeyFields","matchingHeaders","h","sampleValues","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];         // flat tablo datası\r\n  properties: string[];  // tablo başlıkları\r\n  prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n  via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır, önce BTM'yi dener; olmazsa local parser'a düşer.\r\n   * Sonuç: tablo (flat) + opsiyonel prettyJson\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    // 1) BTM'yi dene (2 sn timeout)\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(2000),\r\n          catchError(err => throwError(() => err))\r\n        )\r\n      );\r\n\r\n      // --- CSV'yi dönüştür ---\r\n      const delimiter = this.detectDelimiter(csvString);\r\n      const defaultOptions: CsvOptions = {\r\n        hasHeader: false,                  // BTM Type/Key/Value kolonları header'sız gelir\r\n        skipEmptyLines: true,\r\n        selectedDelimiter: delimiter,\r\n        doubleQuoteWrap: false,\r\n        selectedRowDelimiter: 'newline',\r\n        rowPrefix: '',\r\n        rowSuffix: '',\r\n        selectedEncoding: 'utf-8',\r\n        selectedQuoteOption: 'none',\r\n        trimWhitespace: true,\r\n      };\r\n      const options: CsvOptions = { ...(csvOptions || defaultOptions), hasHeader: false, selectedDelimiter: delimiter };\r\n\r\n      const csvFile = new File([csvString], 'btm.csv', { type: 'text/csv' });\r\n      const converterResult = await this.csvFileConverter.convert(csvFile, options);\r\n\r\n      const records: Array<Record<string, any>> = converterResult.result || [];\r\n\r\n      // 2) Type/Key/Value formatı algıla\r\n      let isTypeKeyValue = false;\r\n      let typeField = '';\r\n      let keyField = '';\r\n      let valueField = '';\r\n\r\n      console.log('CSV dönüşüm sonucu records:', records.length);\r\n      if (records.length > 0) {\r\n        console.log('İlk kayıt anahtarları:', Object.keys(records[0]));\r\n        console.log('İlk kayıt değerleri:', Object.values(records[0]));\r\n      }\r\n      \r\n      const possibleFormats = [\r\n        { type: 'column1', key: 'column2', value: 'column3' }, // header:false\r\n        { type: 'Type', key: 'Key', value: 'Value' },          // header:true\r\n        { type: 'type', key: 'key', value: 'value' },          // header:true (lower)\r\n        { type: '0', key: '1', value: '2' }                    // index bazlı\r\n      ];\r\n\r\n      for (const format of possibleFormats) {\r\n        const hasType = records.length > 0 && records[0][format.type] !== undefined;\r\n        const hasKey  = records.length > 0 && records[0][format.key]  !== undefined;\r\n        const hasVal  = records.length > 0 && records[0][format.value]!== undefined;\r\n        \r\n        if (!hasType || !hasKey || !hasVal) {\r\n          console.log(`Format kontrol (${format.type},${format.key},${format.value}): Eksik alan`);\r\n          continue;\r\n        }\r\n\r\n        const typeValues = new Set(['Parameters', 'Header', 'Details']);\r\n        const sample = records.slice(0, Math.min(10, records.length));\r\n        \r\n        // Type alanında beklenen değerlerin olup olmadığını kontrol et\r\n        const matchingRecords = sample.filter(r => typeValues.has(r[format.type]));\r\n        console.log(`Format kontrol (${format.type},${format.key},${format.value}): ${matchingRecords.length} eşleşen kayıt`);\r\n        \r\n        if (matchingRecords.length > 0) {\r\n          isTypeKeyValue = true;\r\n          typeField = format.type;\r\n          keyField = format.key;\r\n          valueField = format.value;\r\n          console.log(`Type/Key/Value format tespit edildi: ${typeField}/${keyField}/${valueField}`);\r\n          break;\r\n        }\r\n      }\r\n      \r\n      // CSV içeriğinin ilk 5 satırını incele\r\n      console.log('CSV içeriği ilk 5 satır:');\r\n      const csvLines = csvString.split('\\n').slice(0, 5);\r\n      csvLines.forEach((line, i) => console.log(`Satır ${i+1}: ${line}`));\r\n\r\n      // 3) Type/Key/Value → hedef JSON\r\n      if (isTypeKeyValue) {\r\n        // a) ortak kayıtları (Parameters + Header) topla, Details'i sırala\r\n        const shared: Record<string, string> = {};\r\n        const details: Array<{ type: string; key: string; value: string }> = [];\r\n\r\n        console.log('Total records from CSV:', records.length);\r\n        \r\n        for (const row of records) {\r\n          const t = row[typeField];\r\n          const k = row[keyField];\r\n          const v = (row[valueField] ?? '') as string;\r\n\r\n          if (t === 'Parameters' || t === 'Header') {\r\n            shared[k] = v;\r\n            console.log(`Parameter/Header: ${k} = ${v}`);\r\n          } else if (t === 'Details') {\r\n            details.push({ type: t, key: k, value: v });\r\n            if (k === 'RegisterId') {\r\n              console.log(`Found RegisterId: ${v}`);\r\n            }\r\n          }\r\n        }\r\n        \r\n        console.log(`Found ${Object.keys(shared).length} shared parameters and ${details.length} details records`);\r\n\r\n        // b) RegisterId sınırlarına göre gruplandır\r\n        const groups: Array<Array<{ key: string; value: string }>> = [];\r\n        let buf: Array<{ key: string; value: string }> = [];\r\n        let currentRegisterId = '';\r\n\r\n        const hasRegisterId = details.some(d => d.key === 'RegisterId');\r\n        \r\n        console.log(`Details gruplandırma stratejisi: ${hasRegisterId ? 'RegisterId ile' : 'Tek grup'}`);\r\n        \r\n        if (hasRegisterId) {\r\n          // RegisterId'ye göre grupla\r\n          let detailCounter = 0;\r\n          \r\n          for (const d of details) {\r\n            detailCounter++;\r\n            \r\n            if (d.key === 'RegisterId') {\r\n              // RegisterId göründüğünde yeni grup başlat (önceki grup varsa kaydet)\r\n              if (buf.length > 0) {\r\n                console.log(`Grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\r\n                groups.push([...buf]);\r\n                buf = [];\r\n              }\r\n              currentRegisterId = d.value;\r\n            }\r\n            \r\n            // Her detayı mevcut gruba ekle\r\n            buf.push({ key: d.key, value: d.value });\r\n            \r\n            // Son kayıtta da kontrol et\r\n            if (detailCounter === details.length && buf.length > 0) {\r\n              console.log(`Son grup tamamlandı: RegisterId=${currentRegisterId}, ${buf.length} kayıt`);\r\n              groups.push([...buf]);\r\n            }\r\n          }\r\n          \r\n        } else {\r\n          // RegisterId yoksa tüm detaylar tek grup\r\n          groups.push(details.map(d => ({ key: d.key, value: d.value })));\r\n          console.log('Tüm detaylar tek grupta toplandı:', details.length);\r\n        }\r\n        \r\n        console.log(`Toplam ${groups.length} grup oluşturuldu`);\r\n\r\n        // c) beklenen sabit kolon sırası\r\n        const preferredOrder = [\r\n          'OrderFileId','ProductId','SubProductId','OperationCode','StatusId',\r\n          'CorporateId','OrderDate','VPUserId','CorporateProductId','OperationCodeId',\r\n          'Explanation','ErrorMessage','CorporateCode','DestinationBranchCode','SourceBranchCode',\r\n          'FormattedDate','MonthCode','TransferCurrencyCode','FooterTotalCount','RoundedAmount',\r\n          'FinalAccountNo','DestinationIban','TotalCount','OrderDetails','TransferAmount',\r\n          'TotalAmount','RegisterId'\r\n        ];\r\n\r\n        // d) tüm muhtemel anahtarları çıkar (shared ∪ details)\r\n        const expectedKeys = new Set<string>([\r\n          ...Object.keys(shared),\r\n          ...details.map(d => d.key),\r\n        ]);\r\n\r\n        // e) grupları düz satıra çevir: eksikler \"\" kalsın\r\n        const resultRows: Record<string, any>[] = [];\r\n        \r\n        // Sonuç oluşturma öncesi debug\r\n        console.log('Veri oluşturma için:', groups.length, 'grup,', expectedKeys.size, 'benzersiz alan');\r\n        \r\n        // Her grup için düz obje oluştur\r\n        for (const g of groups) {\r\n          const row: Record<string, any> = {};\r\n          \r\n          // default \"\" ver\r\n          expectedKeys.forEach(k => row[k] = '');\r\n\r\n          // ortak alanları bas\r\n          Object.entries(shared).forEach(([k, v]) => row[k] = (v ?? ''));\r\n\r\n          // grup detaylarını yaz\r\n          for (const { key, value } of g) {\r\n            row[key] = (value ?? '');\r\n          }\r\n          \r\n          let registerIdValue = '';\r\n          for (const item of g) {\r\n            if (item.key === 'RegisterId') {\r\n              registerIdValue = item.value;\r\n              break;\r\n            }\r\n          }\r\n\r\n          console.log(`İşlenen grup - RegisterId: ${registerIdValue || 'YOK'}, Alan sayısı: ${Object.keys(row).length}`);\r\n\r\n          // FOOTER FILTREYI KALDIR - tüm grupları dahil et\r\n          /* \r\n          // footer-only filtre: anlamlı detay yoksa at\r\n          const meaningful = ['OrderDetails','TransferAmount','TotalAmount','FinalAccountNo','DestinationIban']\r\n            .some(k => row[k] !== '');\r\n          if (!meaningful) continue;\r\n          */\r\n\r\n          // ErrorMessage datada \"\" kalsın (UI isterse \"-\" gösterir)\r\n          if (row['ErrorMessage'] === undefined) row['ErrorMessage'] = '';\r\n\r\n          // Tabloda - olarak gösterilmesi için boş değerleri - yap\r\n          for (const key of Object.keys(row)) {\r\n            if (row[key] === '' || row[key] === null || row[key] === undefined) {\r\n              row[key] = '-';\r\n            }\r\n          }\r\n\r\n          resultRows.push(row);\r\n        }\r\n        \r\n        console.log(`Sonuç: ${resultRows.length} satır oluşturuldu`);\r\n\r\n        // f) properties: sabit sıraya göre, sonra ekstra anahtarlar\r\n        const orderedProps = [\r\n          ...preferredOrder.filter(k => expectedKeys.has(k)),\r\n          ...Array.from(expectedKeys).filter(k => !preferredOrder.includes(k)),\r\n        ];\r\n\r\n        return {\r\n          result: resultRows,\r\n          properties: orderedProps,\r\n          prettyJson: resultRows,\r\n          via: 'btm',\r\n        };\r\n      }\r\n\r\n      // 4) Düz CSV ise: tüm alanları topla ve boşları \"-\" yap (mevcut davranış)\r\n      const isDirectCsv = this.checkForDirectCsvFormat(records);\r\n      if (isDirectCsv) {\r\n        console.log('Düz CSV formatı algılandı, standart işleme yapılıyor');\r\n        \r\n        // Tüm olası alanları topla\r\n        const allFields = new Set<string>();\r\n        records.forEach(r => Object.keys(r).forEach(k => allFields.add(k)));\r\n        console.log('Bulunan tüm alanlar:', Array.from(allFields));\r\n\r\n        // Beklediğimiz sütun adları - bunların olup olmadığını kontrol et\r\n        const expectedColumns = [\r\n          'Count', 'RoundedAmount', 'OperationCode', 'ErrorMessage', 'FinalAccountNo', \r\n          'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount'\r\n        ];\r\n        \r\n        const missingColumns = expectedColumns.filter(col => !allFields.has(col));\r\n        if (missingColumns.length > 0) {\r\n          console.log('UYARI: Beklenen bazı sütunlar eksik:', missingColumns);\r\n        }\r\n\r\n        // Her kaydı işle\r\n        const processed = records.map(r => {\r\n          const o: Record<string, any> = {};\r\n          \r\n          // Tüm olası alanları her kayda ekle (eksik alanlar - olsun)\r\n          Array.from(allFields).forEach(f => {\r\n            const v = r[f];\r\n            o[f] = (v === undefined || v === null || v === '' || v === '-') ? '-' : v;\r\n          });\r\n          \r\n          return o;\r\n        });\r\n        \r\n        console.log(`İşlenen kayıt sayısı: ${processed.length}`);\r\n        if (processed.length > 0) {\r\n          console.log('İlk işlenen kayıt örneği:', processed[0]);\r\n        }\r\n\r\n        return {\r\n          result: processed,\r\n          properties: Array.from(allFields),\r\n          prettyJson: processed,\r\n          via: 'btm',\r\n        };\r\n      }\r\n\r\n      // 5) Hiçbiri değilse olduğu gibi dön\r\n      return {\r\n        ...converterResult,\r\n        prettyJson: converterResult.result,\r\n        via: 'btm',\r\n      };\r\n    } catch (_btmErr) {\r\n      // 6) BTM başarısızsa local converter'a düş\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n      const localResult = await converter.convert(file, {\r\n        // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n      });\r\n\r\n      return { ...localResult, via: 'local' };\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /** Otomatik delimiter tespiti */\r\n  private detectDelimiter(csvString: string): string {\r\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\r\n    const delimiters = [',', ';', '\\t', '|'];\r\n    const counts: { [key: string]: number } = {};\r\n\r\n    for (const d of delimiters) {\r\n      counts[d] = 0;\r\n      for (const line of lines) {\r\n        let inQuotes = false;\r\n        for (let i = 0; i < line.length; i++) {\r\n          if (line[i] === '\"') inQuotes = !inQuotes;\r\n          else if (line[i] === d && !inQuotes) counts[d]++;\r\n        }\r\n      }\r\n    }\r\n\r\n    let best = ',', max = 0;\r\n    for (const [d, c] of Object.entries(counts)) {\r\n      if (c > max) { max = c; best = d; }\r\n    }\r\n    return best;\r\n  }\r\n\r\n  /** BTM Type/Key/Value değilse düz CSV tespit */\r\n  private checkForDirectCsvFormat(records: Array<Record<string, any>>): boolean {\r\n    if (records.length === 0) {\r\n      console.log('CSV kayıt yok, format kontrolü yapılamaz');\r\n      return false;\r\n    }\r\n    \r\n    const keys = Object.keys(records[0]);\r\n    console.log('Format kontrolü için ilk kayıt anahtarları:', keys);\r\n\r\n    const expectedHeaders = [\r\n      'Count','RoundedAmount','OperationCode','ErrorMessage','FinalAccountNo',\r\n      'DestinationIban','TotalCount','OrderDetails','TransferAmount',\r\n      'count','roundedAmount','operationCode','errorMessage','finalAccountNo',\r\n      'destinationIban','totalCount','orderDetails','transferAmount',\r\n      'Amount','amount','Destination','destination','Operation','operation',\r\n      'Total','total','Order','order','Transfer','transfer',\r\n      'column1','column2','column3','column4','column5'\r\n    ];\r\n\r\n    // Type/Key/Value formatı kontrolü - bu formatsa false döndür\r\n    const typeKeyFields = ['Type', 'Key', 'Value', 'type', 'key', 'value'];\r\n    const matchingTypeKeyFields = typeKeyFields.filter(k => keys.includes(k));\r\n    \r\n    if (matchingTypeKeyFields.length >= 2) {\r\n      console.log('Type/Key/Value formatı tespit edildi, düz CSV olarak işlenmeyecek');\r\n      return false;\r\n    }\r\n\r\n    // Düz CSV formatını kontrol et\r\n    const matchingHeaders = expectedHeaders.filter(h => keys.includes(h));\r\n    console.log(`${matchingHeaders.length} beklenen başlık eşleşti:`, matchingHeaders);\r\n    \r\n    // Daha fazla değer görüntüle\r\n    if (records.length > 0) {\r\n      const sampleValues = Object.values(records[0]);\r\n      console.log('İlk kayıt değerleri:', sampleValues);\r\n    }\r\n    \r\n    // En az 3 başlık eşleşiyor veya en az 5 alan varsa düz CSV kabul et\r\n    const isDirectCsv = matchingHeaders.length >= 3 || keys.length >= 5;\r\n    console.log(`Düz CSV formatı sonucu: ${isDirectCsv ? 'EVET' : 'HAYIR'}`);\r\n    \r\n    return isDirectCsv;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}