{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/JsonConverter-Btm/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file);\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(5000), catchError(err => {\n          console.error('BTM service error:', err);\n          return throwError(() => new Error('BTM servisine ulaşılamadı veya bir hata oluştu.'));\n        })));\n\n        const btmResult = _this.transformBtmCsv(csvString);\n\n        if (btmResult.processedData.length > 0) {\n          console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt'); // Tablo başlıkları için tüm olası anahtarları topla\n\n          const allKeys = new Set();\n          btmResult.processedData.forEach(row => {\n            Object.keys(row).forEach(key => allKeys.add(key));\n          });\n          const properties = Array.from(allKeys);\n          return {\n            result: btmResult.processedData,\n            properties,\n            prettyJson: btmResult.processedData,\n            via: 'btm_grouped_final',\n            parametersData: btmResult.parametersData,\n            headerData: btmResult.headerData\n          };\n        }\n\n        throw new Error('BTM dönüşümü anlamlı bir sonuç üretmedi.');\n      } catch (err) {\n        console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message);\n\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) {\n          throw new Error('XML dönüştürücü bulunamadı (local).');\n        }\n\n        const localResult = yield converter.convert(file, {});\n        return {\n          result: localResult.result,\n          properties: localResult.properties,\n          prettyJson: localResult.result,\n          via: 'local',\n          parametersData: [],\n          headerData: []\n        };\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /**\r\n   * BTM'den gelen CSV'yi gruplayarak ve birleştirerek dönüştürür.\r\n   */\n\n\n  transformBtmCsv(csv) {\n    const rows = this.parseTypeKeyValueCsv(csv);\n\n    if (rows.length === 0) {\n      return {\n        processedData: [],\n        parametersData: [],\n        headerData: [],\n        rawRows: []\n      };\n    }\n\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\n    const headerData = this.extractKeyValue(rows, 'Header');\n    const paramObj = this.toObject(parametersData);\n    const headerObj = this.toObject(headerData);\n    const ibanGroups = this.groupByTypeAsObjects(rows, 'IbanHesap');\n    const detailGroups = this.groupByTypeAsObjects(rows, 'Details');\n    console.log(`Gruplar oluşturuldu: IbanHesap (${ibanGroups.length}), Details (${detailGroups.length})`);\n    const processedData = [];\n    const count = Math.max(ibanGroups.length, detailGroups.length);\n\n    for (let i = 0; i < count; i++) {\n      const iban = ibanGroups[i] || {};\n      const detail = detailGroups[i] || {}; // Önce ana verileri, sonra global verileri birleştir.\n      // Bu, aynı anahtar varsa (örn: TotalAmount) ana verinin öncelikli olmasını sağlar.\n\n      const mergedRecord = { ...paramObj,\n        ...headerObj,\n        ...iban,\n        ...detail\n      };\n      processedData.push(mergedRecord);\n    }\n\n    return {\n      processedData,\n      parametersData,\n      headerData,\n      rawRows: rows\n    };\n  }\n\n  parseTypeKeyValueCsv(csv) {\n    const lines = csv.trim().split(/\\r?\\n/);\n    const rows = [];\n\n    for (const line of lines) {\n      // Boş satırları ve CSV başlığını atla\n      if (!line.trim() || line.toLowerCase().startsWith('type,key,value')) continue;\n      const parts = line.split(',');\n\n      if (parts.length >= 3) {\n        rows.push({\n          type: parts[0].trim(),\n          key: parts[1].trim(),\n          value: parts.slice(2).join(',').trim()\n        });\n      }\n    }\n\n    return rows;\n  }\n\n  extractKeyValue(rows, type) {\n    return rows.filter(row => row.type === type).map(row => ({\n      key: row.key,\n      value: row.value\n    }));\n  }\n\n  toObject(pairs) {\n    return pairs.reduce((obj, item) => ({ ...obj,\n      [item.key]: item.value\n    }), {});\n  }\n  /**\r\n   * Satırları tipine göre mantıksal gruplara ayırır.\r\n   * Bir tipin ilk anahtarı tekrarlandığında yeni bir grup başlatır.\r\n   */\n\n\n  groupByTypeAsObjects(rows, type) {\n    const filteredRows = rows.filter(row => row.type === type);\n    if (filteredRows.length === 0) return [];\n    const groups = [];\n    let currentGroup = {};\n    const firstKey = filteredRows[0].key;\n\n    for (const row of filteredRows) {\n      if (row.key === firstKey && Object.keys(currentGroup).length > 0) {\n        groups.push(currentGroup);\n        currentGroup = {};\n      }\n\n      currentGroup[row.key] = row.value;\n    }\n\n    if (Object.keys(currentGroup).length > 0) {\n      groups.push(currentGroup);\n    }\n\n    return groups;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":";AAKA,SAASA,UAAT,EAAqBC,UAArB,EAAiCC,cAAjC,EAAiDC,OAAjD,QAAgE,MAAhE;;;;;AAmBA,OAAM,MAAOC,sBAAP,CAA6B;EACjCC,YACUC,MADV,EAEUC,aAFV,EAGUC,gBAHV,EAGmD;IAFzC;IACA;IACA;EACN;EAEJ;;;;;;;;EAMMC,UAAU,CAACC,IAAD,EAAaC,UAAb,EAAoC;IAAA;;IAAA;MAClD,MAAMC,OAAO,SAAS,KAAI,CAACC,cAAL,CAAoBH,IAApB,CAAtB;;MAEA,IAAI;QACF,MAAMI,SAAS,SAAiBZ,cAAc,CAC5C,KAAI,CAACI,MAAL,CAAYS,SAAZ,CAAsBH,OAAtB,EAA+BI,IAA/B,CACEb,OAAO,CAAC,IAAD,CADT,EAEEH,UAAU,CAACiB,GAAG,IAAG;UACfC,OAAO,CAACC,KAAR,CAAc,oBAAd,EAAoCF,GAApC;UACA,OAAOhB,UAAU,CAAC,MAAM,IAAImB,KAAJ,CAAU,iDAAV,CAAP,CAAjB;QACD,CAHS,CAFZ,CAD4C,CAA9C;;QAUA,MAAMC,SAAS,GAAG,KAAI,CAACC,eAAL,CAAqBR,SAArB,CAAlB;;QAEA,IAAIO,SAAS,CAACE,aAAV,CAAwBC,MAAxB,GAAiC,CAArC,EAAwC;UACtCN,OAAO,CAACO,GAAR,CAAY,wBAAZ,EAAsCJ,SAAS,CAACE,aAAV,CAAwBC,MAA9D,EAAsE,OAAtE,EADsC,CAGtC;;UACA,MAAME,OAAO,GAAG,IAAIC,GAAJ,EAAhB;UACAN,SAAS,CAACE,aAAV,CAAwBK,OAAxB,CAAgCC,GAAG,IAAG;YACpCC,MAAM,CAACC,IAAP,CAAYF,GAAZ,EAAiBD,OAAjB,CAAyBI,GAAG,IAAIN,OAAO,CAACO,GAAR,CAAYD,GAAZ,CAAhC;UACD,CAFD;UAGA,MAAME,UAAU,GAAGC,KAAK,CAACC,IAAN,CAAWV,OAAX,CAAnB;UAEA,OAAO;YACLW,MAAM,EAAEhB,SAAS,CAACE,aADb;YAELW,UAFK;YAGLI,UAAU,EAAEjB,SAAS,CAACE,aAHjB;YAILgB,GAAG,EAAE,mBAJA;YAKLC,cAAc,EAAEnB,SAAS,CAACmB,cALrB;YAMLC,UAAU,EAAEpB,SAAS,CAACoB;UANjB,CAAP;QAQD;;QAED,MAAM,IAAIrB,KAAJ,CAAU,0CAAV,CAAN;MAED,CAnCD,CAmCE,OAAOH,GAAP,EAAiB;QACjBC,OAAO,CAACC,KAAR,CAAc,0DAAd,EAA0EF,GAAG,CAACyB,OAA9E;;QACA,MAAMC,SAAS,GAAG,KAAI,CAACpC,aAAL,CAAmBqC,YAAnB,CAAgC,KAAhC,CAAlB;;QACA,IAAI,CAACD,SAAL,EAAgB;UACd,MAAM,IAAIvB,KAAJ,CAAU,qCAAV,CAAN;QACD;;QACD,MAAMyB,WAAW,SAASF,SAAS,CAACG,OAAV,CAAkBpC,IAAlB,EAAwB,EAAxB,CAA1B;QACA,OAAO;UACL2B,MAAM,EAAEQ,WAAW,CAACR,MADf;UAELH,UAAU,EAAEW,WAAW,CAACX,UAFnB;UAGLI,UAAU,EAAEO,WAAW,CAACR,MAHnB;UAILE,GAAG,EAAE,OAJA;UAKLC,cAAc,EAAE,EALX;UAMLC,UAAU,EAAE;QANP,CAAP;MAQD;IArDiD;EAsDnD,CAnEgC,CAqEjC;;;EAEQ5B,cAAc,CAACH,IAAD,EAAW;IAC/B,OAAO,IAAIqC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,MAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;;MACAD,MAAM,CAACE,MAAP,GAAgB,MAAMJ,OAAO,CAACE,MAAM,CAACb,MAAR,CAA7B;;MACAa,MAAM,CAACG,OAAP,GAAkBpC,GAAD,IAASgC,MAAM,CAAChC,GAAD,CAAhC;;MACAiC,MAAM,CAACI,UAAP,CAAkB5C,IAAlB;IACD,CALM,CAAP;EAMD;EAED;;;;;EAGQY,eAAe,CAACiC,GAAD,EAAY;IACjC,MAAMC,IAAI,GAAG,KAAKC,oBAAL,CAA0BF,GAA1B,CAAb;;IACA,IAAIC,IAAI,CAAChC,MAAL,KAAgB,CAApB,EAAuB;MACrB,OAAO;QAAED,aAAa,EAAE,EAAjB;QAAqBiB,cAAc,EAAE,EAArC;QAAyCC,UAAU,EAAE,EAArD;QAAyDiB,OAAO,EAAE;MAAlE,CAAP;IACD;;IAED,MAAMlB,cAAc,GAAG,KAAKmB,eAAL,CAAqBH,IAArB,EAA2B,YAA3B,CAAvB;IACA,MAAMf,UAAU,GAAG,KAAKkB,eAAL,CAAqBH,IAArB,EAA2B,QAA3B,CAAnB;IACA,MAAMI,QAAQ,GAAG,KAAKC,QAAL,CAAcrB,cAAd,CAAjB;IACA,MAAMsB,SAAS,GAAG,KAAKD,QAAL,CAAcpB,UAAd,CAAlB;IAEA,MAAMsB,UAAU,GAAG,KAAKC,oBAAL,CAA0BR,IAA1B,EAAgC,WAAhC,CAAnB;IACA,MAAMS,YAAY,GAAG,KAAKD,oBAAL,CAA0BR,IAA1B,EAAgC,SAAhC,CAArB;IAEAtC,OAAO,CAACO,GAAR,CAAY,mCAAmCsC,UAAU,CAACvC,MAAM,eAAeyC,YAAY,CAACzC,MAAM,GAAlG;IAEA,MAAMD,aAAa,GAAkC,EAArD;IACA,MAAM2C,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASL,UAAU,CAACvC,MAApB,EAA4ByC,YAAY,CAACzC,MAAzC,CAAd;;IAEA,KAAK,IAAI6C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAApB,EAA2BG,CAAC,EAA5B,EAAgC;MAC9B,MAAMC,IAAI,GAAGP,UAAU,CAACM,CAAD,CAAV,IAAiB,EAA9B;MACA,MAAME,MAAM,GAAGN,YAAY,CAACI,CAAD,CAAZ,IAAmB,EAAlC,CAF8B,CAI9B;MACA;;MACA,MAAMG,YAAY,GAAG,EACnB,GAAGZ,QADgB;QAEnB,GAAGE,SAFgB;QAGnB,GAAGQ,IAHgB;QAInB,GAAGC;MAJgB,CAArB;MAOAhD,aAAa,CAACkD,IAAd,CAAmBD,YAAnB;IACD;;IAED,OAAO;MACLjD,aADK;MAELiB,cAFK;MAGLC,UAHK;MAILiB,OAAO,EAAEF;IAJJ,CAAP;EAMD;;EAEOC,oBAAoB,CAACF,GAAD,EAAY;IACtC,MAAMmB,KAAK,GAAGnB,GAAG,CAACoB,IAAJ,GAAWC,KAAX,CAAiB,OAAjB,CAAd;IACA,MAAMpB,IAAI,GAAU,EAApB;;IACA,KAAK,MAAMqB,IAAX,IAAmBH,KAAnB,EAA0B;MACxB;MACA,IAAI,CAACG,IAAI,CAACF,IAAL,EAAD,IAAgBE,IAAI,CAACC,WAAL,GAAmBC,UAAnB,CAA8B,gBAA9B,CAApB,EAAqE;MAErE,MAAMC,KAAK,GAAGH,IAAI,CAACD,KAAL,CAAW,GAAX,CAAd;;MACA,IAAII,KAAK,CAACxD,MAAN,IAAgB,CAApB,EAAuB;QACrBgC,IAAI,CAACiB,IAAL,CAAU;UACRQ,IAAI,EAAED,KAAK,CAAC,CAAD,CAAL,CAASL,IAAT,EADE;UAER3C,GAAG,EAAEgD,KAAK,CAAC,CAAD,CAAL,CAASL,IAAT,EAFG;UAGRO,KAAK,EAAEF,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAeC,IAAf,CAAoB,GAApB,EAAyBT,IAAzB;QAHC,CAAV;MAKD;IACF;;IACD,OAAOnB,IAAP;EACD;;EAEOG,eAAe,CAACH,IAAD,EAAcyB,IAAd,EAA0B;IAC/C,OAAOzB,IAAI,CACR6B,MADI,CACGxD,GAAG,IAAIA,GAAG,CAACoD,IAAJ,KAAaA,IADvB,EAEJK,GAFI,CAEAzD,GAAG,KAAK;MAAEG,GAAG,EAAEH,GAAG,CAACG,GAAX;MAAgBkD,KAAK,EAAErD,GAAG,CAACqD;IAA3B,CAAL,CAFH,CAAP;EAGD;;EAEOrB,QAAQ,CAAC0B,KAAD,EAA6C;IAC3D,OAAOA,KAAK,CAACC,MAAN,CAAa,CAACC,GAAD,EAAMC,IAAN,MAAgB,EAAE,GAAGD,GAAL;MAAU,CAACC,IAAI,CAAC1D,GAAN,GAAY0D,IAAI,CAACR;IAA3B,CAAhB,CAAb,EAAkE,EAAlE,CAAP;EACD;EAED;;;;;;EAIQlB,oBAAoB,CAACR,IAAD,EAAcyB,IAAd,EAA0B;IACpD,MAAMU,YAAY,GAAGnC,IAAI,CAAC6B,MAAL,CAAYxD,GAAG,IAAIA,GAAG,CAACoD,IAAJ,KAAaA,IAAhC,CAArB;IACA,IAAIU,YAAY,CAACnE,MAAb,KAAwB,CAA5B,EAA+B,OAAO,EAAP;IAE/B,MAAMoE,MAAM,GAAkC,EAA9C;IACA,IAAIC,YAAY,GAA2B,EAA3C;IAEA,MAAMC,QAAQ,GAAGH,YAAY,CAAC,CAAD,CAAZ,CAAgB3D,GAAjC;;IAEA,KAAK,MAAMH,GAAX,IAAkB8D,YAAlB,EAAgC;MAC9B,IAAI9D,GAAG,CAACG,GAAJ,KAAY8D,QAAZ,IAAwBhE,MAAM,CAACC,IAAP,CAAY8D,YAAZ,EAA0BrE,MAA1B,GAAmC,CAA/D,EAAkE;QAChEoE,MAAM,CAACnB,IAAP,CAAYoB,YAAZ;QACAA,YAAY,GAAG,EAAf;MACD;;MACDA,YAAY,CAAChE,GAAG,CAACG,GAAL,CAAZ,GAAwBH,GAAG,CAACqD,KAA5B;IACD;;IAED,IAAIpD,MAAM,CAACC,IAAP,CAAY8D,YAAZ,EAA0BrE,MAA1B,GAAmC,CAAvC,EAA0C;MACxCoE,MAAM,CAACnB,IAAP,CAAYoB,YAAZ;IACD;;IAED,OAAOD,MAAP;EACD;;AArLgC;;;mBAAtBxF,wBAAsB2F;AAAA;;;SAAtB3F;EAAsB4F,SAAtB5F,sBAAsB;EAAA6F,YADT","names":["catchError","throwError","firstValueFrom","timeout","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","error","Error","btmResult","transformBtmCsv","processedData","length","log","allKeys","Set","forEach","row","Object","keys","key","add","properties","Array","from","result","prettyJson","via","parametersData","headerData","message","converter","getConverter","localResult","convert","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","csv","rows","parseTypeKeyValueCsv","rawRows","extractKeyValue","paramObj","toObject","headerObj","ibanGroups","groupByTypeAsObjects","detailGroups","count","Math","max","i","iban","detail","mergedRecord","push","lines","trim","split","line","toLowerCase","startsWith","parts","type","value","slice","join","filter","map","pairs","reduce","obj","item","filteredRows","groups","currentGroup","firstKey","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\JsonConverter-Btm\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { catchError, throwError, firstValueFrom, timeout } from 'rxjs';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];\r\n  properties?: string[];\r\n  prettyJson?: any;\r\n  via: string;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n}\r\n\r\nexport interface BtmTransformResult {\r\n  processedData: Array<Record<string, string>>;\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n  rawRows: any[];\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır:\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (tüm dönüşüm orada)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(5000),\r\n          catchError(err => {\r\n            console.error('BTM service error:', err);\r\n            return throwError(() => new Error('BTM servisine ulaşılamadı veya bir hata oluştu.'));\r\n          })\r\n        )\r\n      );\r\n\r\n      const btmResult = this.transformBtmCsv(csvString);\r\n\r\n      if (btmResult.processedData.length > 0) {\r\n        console.log('BTM dönüşümü başarılı:', btmResult.processedData.length, 'kayıt');\r\n\r\n        // Tablo başlıkları için tüm olası anahtarları topla\r\n        const allKeys = new Set<string>();\r\n        btmResult.processedData.forEach(row => {\r\n          Object.keys(row).forEach(key => allKeys.add(key));\r\n        });\r\n        const properties = Array.from(allKeys);\r\n\r\n        return {\r\n          result: btmResult.processedData,\r\n          properties,\r\n          prettyJson: btmResult.processedData,\r\n          via: 'btm_grouped_final',\r\n          parametersData: btmResult.parametersData,\r\n          headerData: btmResult.headerData\r\n        };\r\n      }\r\n\r\n      throw new Error('BTM dönüşümü anlamlı bir sonuç üretmedi.');\r\n\r\n    } catch (err: any) {\r\n      console.error('BTM akışı sırasında hata, local XML converter deneniyor:', err.message);\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) {\r\n        throw new Error('XML dönüştürücü bulunamadı (local).');\r\n      }\r\n      const localResult = await converter.convert(file, {});\r\n      return {\r\n        result: localResult.result,\r\n        properties: localResult.properties,\r\n        prettyJson: localResult.result,\r\n        via: 'local',\r\n        parametersData: [],\r\n        headerData: []\r\n      };\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * BTM'den gelen CSV'yi gruplayarak ve birleştirerek dönüştürür.\r\n   */\r\n  private transformBtmCsv(csv: string): BtmTransformResult {\r\n    const rows = this.parseTypeKeyValueCsv(csv);\r\n    if (rows.length === 0) {\r\n      return { processedData: [], parametersData: [], headerData: [], rawRows: [] };\r\n    }\r\n\r\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\r\n    const headerData = this.extractKeyValue(rows, 'Header');\r\n    const paramObj = this.toObject(parametersData);\r\n    const headerObj = this.toObject(headerData);\r\n\r\n    const ibanGroups = this.groupByTypeAsObjects(rows, 'IbanHesap');\r\n    const detailGroups = this.groupByTypeAsObjects(rows, 'Details');\r\n\r\n    console.log(`Gruplar oluşturuldu: IbanHesap (${ibanGroups.length}), Details (${detailGroups.length})`);\r\n\r\n    const processedData: Array<Record<string, string>> = [];\r\n    const count = Math.max(ibanGroups.length, detailGroups.length);\r\n\r\n    for (let i = 0; i < count; i++) {\r\n      const iban = ibanGroups[i] || {};\r\n      const detail = detailGroups[i] || {};\r\n\r\n      // Önce ana verileri, sonra global verileri birleştir.\r\n      // Bu, aynı anahtar varsa (örn: TotalAmount) ana verinin öncelikli olmasını sağlar.\r\n      const mergedRecord = {\r\n        ...paramObj,\r\n        ...headerObj,\r\n        ...iban,\r\n        ...detail,\r\n      };\r\n      \r\n      processedData.push(mergedRecord);\r\n    }\r\n\r\n    return {\r\n      processedData,\r\n      parametersData,\r\n      headerData,\r\n      rawRows: rows\r\n    };\r\n  }\r\n\r\n  private parseTypeKeyValueCsv(csv: string): any[] {\r\n    const lines = csv.trim().split(/\\r?\\n/);\r\n    const rows: any[] = [];\r\n    for (const line of lines) {\r\n      // Boş satırları ve CSV başlığını atla\r\n      if (!line.trim() || line.toLowerCase().startsWith('type,key,value')) continue;\r\n      \r\n      const parts = line.split(',');\r\n      if (parts.length >= 3) {\r\n        rows.push({\r\n          type: parts[0].trim(),\r\n          key: parts[1].trim(),\r\n          value: parts.slice(2).join(',').trim()\r\n        });\r\n      }\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  private extractKeyValue(rows: any[], type: string): Array<{ key: string; value: string }> {\r\n    return rows\r\n      .filter(row => row.type === type)\r\n      .map(row => ({ key: row.key, value: row.value }));\r\n  }\r\n\r\n  private toObject(pairs: Array<{ key: string; value: string }>): Record<string, string> {\r\n    return pairs.reduce((obj, item) => ({ ...obj, [item.key]: item.value }), {});\r\n  }\r\n\r\n  /**\r\n   * Satırları tipine göre mantıksal gruplara ayırır.\r\n   * Bir tipin ilk anahtarı tekrarlandığında yeni bir grup başlatır.\r\n   */\r\n  private groupByTypeAsObjects(rows: any[], type: string): Array<Record<string, string>> {\r\n    const filteredRows = rows.filter(row => row.type === type);\r\n    if (filteredRows.length === 0) return [];\r\n\r\n    const groups: Array<Record<string, string>> = [];\r\n    let currentGroup: Record<string, string> = {};\r\n    \r\n    const firstKey = filteredRows[0].key;\r\n\r\n    for (const row of filteredRows) {\r\n      if (row.key === firstKey && Object.keys(currentGroup).length > 0) {\r\n        groups.push(currentGroup);\r\n        currentGroup = {};\r\n      }\r\n      currentGroup[row.key] = row.value;\r\n    }\r\n\r\n    if (Object.keys(currentGroup).length > 0) {\r\n      groups.push(currentGroup);\r\n    }\r\n\r\n    return groups;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}