{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * XML dosyasını alır, önce BTM'yi dener; olmazsa local parser'a düşer.\r\n   * Sonuç: tablo (flat) + opsiyonel prettyJson\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err)))); // --- CSV'yi dönüştür ---\n\n        const delimiter = _this.detectDelimiter(csvString);\n\n        const defaultOptions = {\n          hasHeader: false,\n          skipEmptyLines: true,\n          selectedDelimiter: delimiter,\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        };\n        const options = { ...(csvOptions || defaultOptions),\n          hasHeader: false,\n          selectedDelimiter: delimiter\n        };\n        const csvFile = new File([csvString], 'btm.csv', {\n          type: 'text/csv'\n        });\n        const converterResult = yield _this.csvFileConverter.convert(csvFile, options);\n        const records = converterResult.result || []; // 2) Type/Key/Value formatı algıla\n\n        let isTypeKeyValue = false;\n        let typeField = '';\n        let keyField = '';\n        let valueField = '';\n        const possibleFormats = [{\n          type: 'column1',\n          key: 'column2',\n          value: 'column3'\n        }, {\n          type: 'Type',\n          key: 'Key',\n          value: 'Value'\n        }, {\n          type: 'type',\n          key: 'key',\n          value: 'value'\n        }, {\n          type: '0',\n          key: '1',\n          value: '2'\n        } // index bazlı\n        ];\n\n        for (const format of possibleFormats) {\n          const hasType = records.length > 0 && records[0][format.type] !== undefined;\n          const hasKey = records.length > 0 && records[0][format.key] !== undefined;\n          const hasVal = records.length > 0 && records[0][format.value] !== undefined;\n          if (!hasType || !hasKey || !hasVal) continue;\n          const typeValues = new Set(['Parameters', 'Header', 'Details']);\n          const sample = records.slice(0, Math.min(10, records.length));\n          const ok = sample.some(r => typeValues.has(r[format.type]));\n\n          if (ok) {\n            isTypeKeyValue = true;\n            typeField = format.type;\n            keyField = format.key;\n            valueField = format.value;\n            break;\n          }\n        } // 3) Type/Key/Value → hedef JSON\n\n\n        if (isTypeKeyValue) {\n          // a) ortak kayıtları (Parameters + Header) topla, Details'i sırala\n          const shared = {};\n          const details = [];\n\n          for (const row of records) {\n            const t = row[typeField];\n            const k = row[keyField];\n            const v = row[valueField] ?? '';\n\n            if (t === 'Parameters' || t === 'Header') {\n              shared[k] = v;\n            } else if (t === 'Details') {\n              details.push({\n                type: t,\n                key: k,\n                value: v\n              });\n            }\n          } // b) RegisterId sınırlarına göre gruplandır\n\n\n          const groups = [];\n          let buf = [];\n          const hasRegisterId = details.some(d => d.key === 'RegisterId');\n\n          if (hasRegisterId) {\n            for (const d of details) {\n              if (d.key === 'RegisterId' && buf.length > 0) {\n                groups.push([...buf]);\n                buf = [];\n              }\n\n              buf.push({\n                key: d.key,\n                value: d.value\n              });\n            }\n\n            if (buf.length > 0) groups.push(buf);\n          } else {\n            // RegisterId yoksa tüm detaylar tek grup\n            groups.push(details.map(d => ({\n              key: d.key,\n              value: d.value\n            })));\n          } // c) beklenen sabit kolon sırası\n\n\n          const preferredOrder = ['OrderFileId', 'ProductId', 'SubProductId', 'OperationCode', 'StatusId', 'CorporateId', 'OrderDate', 'VPUserId', 'CorporateProductId', 'OperationCodeId', 'Explanation', 'ErrorMessage', 'CorporateCode', 'DestinationBranchCode', 'SourceBranchCode', 'FormattedDate', 'MonthCode', 'TransferCurrencyCode', 'FooterTotalCount', 'RoundedAmount', 'FinalAccountNo', 'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount', 'TotalAmount', 'RegisterId']; // d) tüm muhtemel anahtarları çıkar (shared ∪ details)\n\n          const expectedKeys = new Set([...Object.keys(shared), ...details.map(d => d.key)]); // e) grupları düz satıra çevir: eksikler \"\" kalsın\n\n          const resultRows = [];\n\n          for (const g of groups) {\n            const row = {}; // default \"\" ver\n\n            expectedKeys.forEach(k => row[k] = ''); // ortak alanları bas\n\n            Object.entries(shared).forEach(([k, v]) => row[k] = v ?? ''); // grup detaylarını yaz\n\n            for (const {\n              key,\n              value\n            } of g) {\n              row[key] = value ?? '';\n            } // footer-only filtre: anlamlı detay yoksa at\n\n\n            const meaningful = ['OrderDetails', 'TransferAmount', 'TotalAmount', 'FinalAccountNo', 'DestinationIban'].some(k => row[k] !== '');\n            if (!meaningful) continue; // ErrorMessage datada \"\" kalsın (UI isterse \"-\" gösterir)\n\n            if (row['ErrorMessage'] === undefined) row['ErrorMessage'] = '';\n            resultRows.push(row);\n          } // f) properties: sabit sıraya göre, sonra ekstra anahtarlar\n\n\n          const orderedProps = [...preferredOrder.filter(k => expectedKeys.has(k)), ...Array.from(expectedKeys).filter(k => !preferredOrder.includes(k))];\n          return {\n            result: resultRows,\n            properties: orderedProps,\n            prettyJson: resultRows,\n            via: 'btm'\n          };\n        } // 4) Düz CSV ise: tüm alanları topla ve boşları \"-\" yap (mevcut davranış)\n\n\n        const isDirectCsv = _this.checkForDirectCsvFormat(records);\n\n        if (isDirectCsv) {\n          const allFields = new Set();\n          records.forEach(r => Object.keys(r).forEach(k => allFields.add(k)));\n          const processed = records.map(r => {\n            const o = {};\n            Array.from(allFields).forEach(f => {\n              const v = r[f];\n              o[f] = v === undefined || v === null || v === '' || v === '-' ? '-' : v;\n            });\n            return o;\n          });\n          return {\n            result: processed,\n            properties: Array.from(allFields),\n            prettyJson: processed,\n            via: 'btm'\n          };\n        } // 5) Hiçbiri değilse olduğu gibi dön\n\n\n        return { ...converterResult,\n          prettyJson: converterResult.result,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 6) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        });\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /** Otomatik delimiter tespiti */\n\n\n  detectDelimiter(csvString) {\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\n    const delimiters = [',', ';', '\\t', '|'];\n    const counts = {};\n\n    for (const d of delimiters) {\n      counts[d] = 0;\n\n      for (const line of lines) {\n        let inQuotes = false;\n\n        for (let i = 0; i < line.length; i++) {\n          if (line[i] === '\"') inQuotes = !inQuotes;else if (line[i] === d && !inQuotes) counts[d]++;\n        }\n      }\n    }\n\n    let best = ',',\n        max = 0;\n\n    for (const [d, c] of Object.entries(counts)) {\n      if (c > max) {\n        max = c;\n        best = d;\n      }\n    }\n\n    return best;\n  }\n  /** BTM Type/Key/Value değilse düz CSV tespit */\n\n\n  checkForDirectCsvFormat(records) {\n    if (records.length === 0) return false;\n    const keys = Object.keys(records[0]);\n    const expectedHeaders = ['Count', 'RoundedAmount', 'OperationCode', 'ErrorMessage', 'FinalAccountNo', 'DestinationIban', 'TotalCount', 'OrderDetails', 'TransferAmount', 'count', 'roundedAmount', 'operationCode', 'errorMessage', 'finalAccountNo', 'destinationIban', 'totalCount', 'orderDetails', 'transferAmount', 'Amount', 'amount', 'Destination', 'destination', 'Operation', 'operation', 'Total', 'total', 'Order', 'order', 'Transfer', 'transfer', 'column1', 'column2', 'column3', 'column4', 'column5'];\n    const hasTypeKeyFormat = keys.some(k => ['Type', 'Key', 'Value', 'type', 'key', 'value'].includes(k));\n    if (hasTypeKeyFormat) return false;\n    const matching = expectedHeaders.filter(h => keys.includes(h));\n    return matching.length >= 3 || keys.length >= 5;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","delimiter","detectDelimiter","defaultOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","options","csvFile","File","type","converterResult","convert","records","result","isTypeKeyValue","typeField","keyField","valueField","possibleFormats","key","value","format","hasType","length","undefined","hasKey","hasVal","typeValues","Set","sample","slice","Math","min","ok","some","r","has","shared","details","row","t","k","v","push","groups","buf","hasRegisterId","d","map","preferredOrder","expectedKeys","Object","keys","resultRows","g","forEach","entries","meaningful","orderedProps","filter","Array","from","includes","properties","prettyJson","via","isDirectCsv","checkForDirectCsvFormat","allFields","add","processed","o","f","_btmErr","converter","getConverter","Error","localResult","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","lines","trim","split","delimiters","counts","line","inQuotes","i","best","max","c","expectedHeaders","hasTypeKeyFormat","matching","h","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];         // flat tablo datası\r\n  properties: string[];  // tablo başlıkları\r\n  prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n  via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * XML dosyasını alır, önce BTM'yi dener; olmazsa local parser'a düşer.\r\n   * Sonuç: tablo (flat) + opsiyonel prettyJson\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    // 1) BTM'yi dene (2 sn timeout)\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(2000),\r\n          catchError(err => throwError(() => err))\r\n        )\r\n      );\r\n\r\n      // --- CSV'yi dönüştür ---\r\n      const delimiter = this.detectDelimiter(csvString);\r\n      const defaultOptions: CsvOptions = {\r\n        hasHeader: false,                  // BTM Type/Key/Value kolonları header'sız gelir\r\n        skipEmptyLines: true,\r\n        selectedDelimiter: delimiter,\r\n        doubleQuoteWrap: false,\r\n        selectedRowDelimiter: 'newline',\r\n        rowPrefix: '',\r\n        rowSuffix: '',\r\n        selectedEncoding: 'utf-8',\r\n        selectedQuoteOption: 'none',\r\n        trimWhitespace: true,\r\n      };\r\n      const options: CsvOptions = { ...(csvOptions || defaultOptions), hasHeader: false, selectedDelimiter: delimiter };\r\n\r\n      const csvFile = new File([csvString], 'btm.csv', { type: 'text/csv' });\r\n      const converterResult = await this.csvFileConverter.convert(csvFile, options);\r\n\r\n      const records: Array<Record<string, any>> = converterResult.result || [];\r\n\r\n      // 2) Type/Key/Value formatı algıla\r\n      let isTypeKeyValue = false;\r\n      let typeField = '';\r\n      let keyField = '';\r\n      let valueField = '';\r\n\r\n      const possibleFormats = [\r\n        { type: 'column1', key: 'column2', value: 'column3' }, // header:false\r\n        { type: 'Type', key: 'Key', value: 'Value' },          // header:true\r\n        { type: 'type', key: 'key', value: 'value' },          // header:true (lower)\r\n        { type: '0', key: '1', value: '2' }                    // index bazlı\r\n      ];\r\n\r\n      for (const format of possibleFormats) {\r\n        const hasType = records.length > 0 && records[0][format.type] !== undefined;\r\n        const hasKey  = records.length > 0 && records[0][format.key]  !== undefined;\r\n        const hasVal  = records.length > 0 && records[0][format.value]!== undefined;\r\n        if (!hasType || !hasKey || !hasVal) continue;\r\n\r\n        const typeValues = new Set(['Parameters', 'Header', 'Details']);\r\n        const sample = records.slice(0, Math.min(10, records.length));\r\n        const ok = sample.some(r => typeValues.has(r[format.type]));\r\n        if (ok) {\r\n          isTypeKeyValue = true;\r\n          typeField = format.type;\r\n          keyField = format.key;\r\n          valueField = format.value;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // 3) Type/Key/Value → hedef JSON\r\n      if (isTypeKeyValue) {\r\n        // a) ortak kayıtları (Parameters + Header) topla, Details'i sırala\r\n        const shared: Record<string, string> = {};\r\n        const details: Array<{ type: string; key: string; value: string }> = [];\r\n\r\n        for (const row of records) {\r\n          const t = row[typeField];\r\n          const k = row[keyField];\r\n          const v = (row[valueField] ?? '') as string;\r\n\r\n          if (t === 'Parameters' || t === 'Header') {\r\n            shared[k] = v;\r\n          } else if (t === 'Details') {\r\n            details.push({ type: t, key: k, value: v });\r\n          }\r\n        }\r\n\r\n        // b) RegisterId sınırlarına göre gruplandır\r\n        const groups: Array<Array<{ key: string; value: string }>> = [];\r\n        let buf: Array<{ key: string; value: string }> = [];\r\n\r\n        const hasRegisterId = details.some(d => d.key === 'RegisterId');\r\n        if (hasRegisterId) {\r\n          for (const d of details) {\r\n            if (d.key === 'RegisterId' && buf.length > 0) {\r\n              groups.push([...buf]);\r\n              buf = [];\r\n            }\r\n            buf.push({ key: d.key, value: d.value });\r\n          }\r\n          if (buf.length > 0) groups.push(buf);\r\n        } else {\r\n          // RegisterId yoksa tüm detaylar tek grup\r\n          groups.push(details.map(d => ({ key: d.key, value: d.value })));\r\n        }\r\n\r\n        // c) beklenen sabit kolon sırası\r\n        const preferredOrder = [\r\n          'OrderFileId','ProductId','SubProductId','OperationCode','StatusId',\r\n          'CorporateId','OrderDate','VPUserId','CorporateProductId','OperationCodeId',\r\n          'Explanation','ErrorMessage','CorporateCode','DestinationBranchCode','SourceBranchCode',\r\n          'FormattedDate','MonthCode','TransferCurrencyCode','FooterTotalCount','RoundedAmount',\r\n          'FinalAccountNo','DestinationIban','TotalCount','OrderDetails','TransferAmount',\r\n          'TotalAmount','RegisterId'\r\n        ];\r\n\r\n        // d) tüm muhtemel anahtarları çıkar (shared ∪ details)\r\n        const expectedKeys = new Set<string>([\r\n          ...Object.keys(shared),\r\n          ...details.map(d => d.key),\r\n        ]);\r\n\r\n        // e) grupları düz satıra çevir: eksikler \"\" kalsın\r\n        const resultRows: Record<string, any>[] = [];\r\n        for (const g of groups) {\r\n          const row: Record<string, any> = {};\r\n          // default \"\" ver\r\n          expectedKeys.forEach(k => row[k] = '');\r\n\r\n          // ortak alanları bas\r\n          Object.entries(shared).forEach(([k, v]) => row[k] = (v ?? ''));\r\n\r\n          // grup detaylarını yaz\r\n          for (const { key, value } of g) {\r\n            row[key] = (value ?? '');\r\n          }\r\n\r\n          // footer-only filtre: anlamlı detay yoksa at\r\n          const meaningful = ['OrderDetails','TransferAmount','TotalAmount','FinalAccountNo','DestinationIban']\r\n            .some(k => row[k] !== '');\r\n          if (!meaningful) continue;\r\n\r\n          // ErrorMessage datada \"\" kalsın (UI isterse \"-\" gösterir)\r\n          if (row['ErrorMessage'] === undefined) row['ErrorMessage'] = '';\r\n\r\n          resultRows.push(row);\r\n        }\r\n\r\n        // f) properties: sabit sıraya göre, sonra ekstra anahtarlar\r\n        const orderedProps = [\r\n          ...preferredOrder.filter(k => expectedKeys.has(k)),\r\n          ...Array.from(expectedKeys).filter(k => !preferredOrder.includes(k)),\r\n        ];\r\n\r\n        return {\r\n          result: resultRows,\r\n          properties: orderedProps,\r\n          prettyJson: resultRows,\r\n          via: 'btm',\r\n        };\r\n      }\r\n\r\n      // 4) Düz CSV ise: tüm alanları topla ve boşları \"-\" yap (mevcut davranış)\r\n      const isDirectCsv = this.checkForDirectCsvFormat(records);\r\n      if (isDirectCsv) {\r\n        const allFields = new Set<string>();\r\n        records.forEach(r => Object.keys(r).forEach(k => allFields.add(k)));\r\n\r\n        const processed = records.map(r => {\r\n          const o: Record<string, any> = {};\r\n          Array.from(allFields).forEach(f => {\r\n            const v = r[f];\r\n            o[f] = (v === undefined || v === null || v === '' || v === '-') ? '-' : v;\r\n          });\r\n          return o;\r\n        });\r\n\r\n        return {\r\n          result: processed,\r\n          properties: Array.from(allFields),\r\n          prettyJson: processed,\r\n          via: 'btm',\r\n        };\r\n      }\r\n\r\n      // 5) Hiçbiri değilse olduğu gibi dön\r\n      return {\r\n        ...converterResult,\r\n        prettyJson: converterResult.result,\r\n        via: 'btm',\r\n      };\r\n    } catch (_btmErr) {\r\n      // 6) BTM başarısızsa local converter'a düş\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n      const localResult = await converter.convert(file, {\r\n        // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n      });\r\n\r\n      return { ...localResult, via: 'local' };\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /** Otomatik delimiter tespiti */\r\n  private detectDelimiter(csvString: string): string {\r\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\r\n    const delimiters = [',', ';', '\\t', '|'];\r\n    const counts: { [key: string]: number } = {};\r\n\r\n    for (const d of delimiters) {\r\n      counts[d] = 0;\r\n      for (const line of lines) {\r\n        let inQuotes = false;\r\n        for (let i = 0; i < line.length; i++) {\r\n          if (line[i] === '\"') inQuotes = !inQuotes;\r\n          else if (line[i] === d && !inQuotes) counts[d]++;\r\n        }\r\n      }\r\n    }\r\n\r\n    let best = ',', max = 0;\r\n    for (const [d, c] of Object.entries(counts)) {\r\n      if (c > max) { max = c; best = d; }\r\n    }\r\n    return best;\r\n  }\r\n\r\n  /** BTM Type/Key/Value değilse düz CSV tespit */\r\n  private checkForDirectCsvFormat(records: Array<Record<string, any>>): boolean {\r\n    if (records.length === 0) return false;\r\n    const keys = Object.keys(records[0]);\r\n\r\n    const expectedHeaders = [\r\n      'Count','RoundedAmount','OperationCode','ErrorMessage','FinalAccountNo',\r\n      'DestinationIban','TotalCount','OrderDetails','TransferAmount',\r\n      'count','roundedAmount','operationCode','errorMessage','finalAccountNo',\r\n      'destinationIban','totalCount','orderDetails','transferAmount',\r\n      'Amount','amount','Destination','destination','Operation','operation',\r\n      'Total','total','Order','order','Transfer','transfer',\r\n      'column1','column2','column3','column4','column5'\r\n    ];\r\n\r\n    const hasTypeKeyFormat = keys.some(k => ['Type','Key','Value','type','key','value'].includes(k));\r\n    if (hasTypeKeyFormat) return false;\r\n\r\n    const matching = expectedHeaders.filter(h => keys.includes(h));\r\n    return matching.length >= 3 || keys.length >= 5;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}