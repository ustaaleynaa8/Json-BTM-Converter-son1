{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/JsonConverter-Btm/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { catchError, firstValueFrom, throwError, timeout } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\n/*  Gruplamada yeni kayıt başlangıcını sezmek için ipucu olabilecek alanlar */\n\nconst GROUP_BOUNDARY_KEYS = ['DestinationIban', 'FinalAccountNo', 'Iban', 'HesapNo', 'OrderDetails'];\n/* ---------------------- Service ---------------------- */\n\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (fallback)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\n\n\n  processXml(file, csvOptions) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file);\n\n      try {\n        // --- 1) BTM denemesi (örnek: 2 sn timeout)\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err))));\n\n        const btmResult = _this.transformBtmCsv(csvString);\n\n        if (btmResult.processedData.length > 0) {\n          // Flat tablo kolonları: temel alanlar + Param/Header anahtarları\n          const baseProps = ['DestinationIban', 'FinalAccountNo', 'TotalCount', 'OrderDetails', 'TransferAmount', 'TotalAmount', 'RegisterId'];\n\n          const properties = _this.buildPropertyList(baseProps, btmResult.parametersData, btmResult.headerData); // Flat satırlara Parameters & Header değerlerini enjekte et\n\n\n          const resultRows = btmResult.processedData.map(row => _this.mergeParamHeader(row, btmResult.parametersData, btmResult.headerData));\n          return {\n            result: resultRows,\n            properties,\n            prettyJson: btmResult,\n            via: 'btm',\n            parametersData: btmResult.parametersData,\n            headerData: btmResult.headerData\n          };\n        } // --- 1.b) BTM CSV’yi genel CSV dönüştürücüne pasla (header’sız kabul et)\n\n\n        const delimiter = _this.detectDelimiter(csvString);\n\n        const defaultOptions = {\n          hasHeader: false,\n          skipEmptyLines: true,\n          selectedDelimiter: delimiter,\n          doubleQuoteWrap: false,\n          selectedRowDelimiter: 'newline',\n          rowPrefix: '',\n          rowSuffix: '',\n          selectedEncoding: 'utf-8',\n          selectedQuoteOption: 'none',\n          trimWhitespace: true\n        };\n        const options = { ...(csvOptions ?? defaultOptions),\n          selectedDelimiter: delimiter\n        };\n        const csvFile = new File([csvString], 'btm.csv', {\n          type: 'text/csv'\n        });\n        const converterResult = yield _this.csvFileConverter.convert(csvFile, options);\n        return {\n          result: converterResult.result,\n          properties: converterResult.properties,\n          prettyJson: converterResult.result,\n          via: 'btm',\n          parametersData: [],\n          headerData: []\n        };\n      } catch {\n        // --- 2) Local XML converter’a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) {\n          throw new Error('XML dönüştürücü bulunamadı (local).');\n        }\n\n        const localResult = yield converter.convert(file, {});\n        return {\n          result: localResult.result,\n          properties: localResult.properties,\n          prettyJson: localResult.result,\n          via: 'local',\n          parametersData: [],\n          headerData: []\n        };\n      }\n    })();\n  }\n  /* ---------------------- Helpers ---------------------- */\n\n\n  readFileAsText(file) {\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n\n        reader.onload = () => resolve(String(reader.result ?? ''));\n\n        reader.onerror = err => reject(err);\n\n        reader.readAsText(file);\n      });\n    })();\n  }\n  /** Basit delimiter tespiti (tırnak içindeki ayraçları dikkate alır) */\n\n\n  detectDelimiter(csvString) {\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\n    const candidates = [',', ';', '\\t', '|'];\n    const counts = Object.fromEntries(candidates.map(d => [d, 0]));\n\n    for (const line of lines) {\n      for (const d of candidates) {\n        counts[d] += this.countDelimiterOutsideQuotes(line, d);\n      }\n    }\n\n    let best = ',';\n    let max = -1;\n\n    for (const [d, c] of Object.entries(counts)) {\n      if (c > max) {\n        max = c;\n        best = d;\n      }\n    }\n\n    return best;\n  }\n\n  countDelimiterOutsideQuotes(line, delimiter) {\n    let cnt = 0,\n        inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n      if (ch === '\"') inQuotes = !inQuotes;else if (!inQuotes && ch === delimiter) cnt++;\n    }\n\n    return cnt;\n  }\n  /* ---------------------- BTM CSV -> JSON ---------------------- */\n\n\n  transformBtmCsv(csv) {\n    const rows = this.parseTypeKeyValueCsv(csv);\n\n    if (rows.length === 0) {\n      return {\n        processedData: [],\n        parametersData: [],\n        headerData: [],\n        rawRows: []\n      };\n    } // Parameters / Header koleksiyonları\n\n\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\n    const headerData = this.extractKeyValue(rows, 'Header'); // Gruplar\n\n    let ibanGroups = this.groupByTypeAsObjects(rows, 'IbanHesap');\n    let detailGroups = this.groupByTypeAsObjects(rows, 'Details'); // IbanHesap yoksa Details’ten alan üret\n\n    if (ibanGroups.length === 0 && detailGroups.length > 0) {\n      const tmp = [];\n\n      for (const det of detailGroups) {\n        const finalNo = det['FinalAccountNo'] || det['HesapNo'] || '';\n        const iban = det['DestinationIban'] || det['Iban'] || '';\n\n        if (finalNo || iban) {\n          tmp.push({\n            FinalAccountNo: finalNo,\n            DestinationIban: iban,\n            HesapNo: finalNo,\n            Iban: iban\n          });\n        }\n      }\n\n      if (tmp.length > 0) ibanGroups = tmp;\n    } // Details yoksa ama IbanHesap varsa boş iskelet üret\n\n\n    if (detailGroups.length === 0 && ibanGroups.length > 0) {\n      detailGroups = ibanGroups.map(() => ({\n        TotalCount: '',\n        OrderDetails: '',\n        TransferAmount: '',\n        TotalAmount: '',\n        ToplamTutar: '',\n        Toplam: '',\n        RegisterId: '',\n        Sicil: '',\n        SicilNo: '',\n        RegistrationId: ''\n      }));\n    } // Param/Header objeleri (eksik alanları tamamlamak için)\n\n\n    const paramObj = this.toObject(parametersData);\n    const headerObj = this.toObject(headerData); // UI tablosu için nihai satırlar\n\n    const processedData = ibanGroups.map((ibanObj, i) => {\n      const det = detailGroups[i] ?? {};\n      let totalAmount = det['TotalAmount'] || det['ToplamTutar'] || det['Toplam'] || '';\n      let registerId = det['RegisterId'] || det['Sicil'] || det['SicilNo'] || det['RegistrationId'] || ''; // Eksikse diğer detail gruplarında ara\n\n      if (!totalAmount || !registerId) {\n        for (let j = 0; j < detailGroups.length; j++) {\n          const g = detailGroups[j] ?? {};\n          if (!totalAmount) totalAmount = g['TotalAmount'] || g['ToplamTutar'] || g['Toplam'] || '';\n          if (!registerId && j === i) registerId = g['RegisterId'] || g['Sicil'] || g['SicilNo'] || g['RegistrationId'] || '';\n        }\n\n        if (!registerId) {\n          for (const g of detailGroups) {\n            registerId = g['RegisterId'] || g['Sicil'] || g['SicilNo'] || g['RegistrationId'] || '';\n            if (registerId) break;\n          }\n        }\n      } // Hâlâ eksikse Param/Header’dan tamamla\n\n\n      if (!totalAmount) totalAmount = paramObj['TotalAmount'] || headerObj['TotalAmount'] || '';\n      if (!registerId) registerId = paramObj['RegisterId'] || headerObj['RegisterId'] || paramObj['Sicil'] || headerObj['Sicil'] || '';\n      return {\n        DestinationIban: ibanObj['DestinationIban'] || ibanObj['Iban'] || '',\n        FinalAccountNo: ibanObj['FinalAccountNo'] || ibanObj['HesapNo'] || '',\n        TotalCount: det['TotalCount'] || '',\n        OrderDetails: det['OrderDetails'] || det['Detail'] || '',\n        TransferAmount: det['TransferAmount'] || det['Miktar'] || '',\n        TotalAmount: totalAmount || '---',\n        RegisterId: registerId || '---'\n      };\n    });\n    return {\n      processedData,\n      parametersData,\n      headerData,\n      rawRows: rows\n    };\n  }\n  /** “Type,Key,Value” formatındaki CSV’yi güvenli ayrıştırır */\n\n\n  parseTypeKeyValueCsv(csv) {\n    const lines = csv.trim().split(/\\r?\\n/);\n    if (lines.length === 0) return []; // Ayraç tespiti (satırların kendisine göre)\n\n    const delimiter = this.detectDelimiter(csv);\n    const rows = [];\n\n    for (const rawLine of lines) {\n      const line = rawLine.trim();\n      if (!line) continue;\n      const cols = this.splitCsvLine(line, delimiter);\n      if (cols.length < 3) continue;\n      const [type, key, ...rest] = cols;\n      const value = rest.join(delimiter).trim();\n      rows.push({\n        type: type ?? String(type),\n        key: key ?? '',\n        value: value.replace(/^\"|\"$/g, '') // dış tırnakları soy\n\n      });\n    }\n\n    return rows;\n  }\n  /** Tırnaklı alanları doğru parçalayarak satırı ayırır */\n\n\n  splitCsvLine(line, delimiter) {\n    const out = [];\n    let cur = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n\n      if (ch === '\"') {\n        // Çift tırnak kaçışı: \"\" -> \"\n        if (inQuotes && line[i + 1] === '\"') {\n          cur += '\"';\n          i++;\n        } else {\n          inQuotes = !inQuotes;\n        }\n      } else if (ch === delimiter && !inQuotes) {\n        out.push(cur);\n        cur = '';\n      } else {\n        cur += ch;\n      }\n    }\n\n    out.push(cur);\n    return out.map(s => s.trim());\n  }\n\n  extractKeyValue(rows, type) {\n    return rows.filter(r => r.type === type).map(r => ({\n      key: r.key ?? '',\n      value: r.value ?? ''\n    }));\n  }\n\n  toObject(pairs) {\n    const obj = {};\n\n    for (const {\n      key,\n      value\n    } of pairs) {\n      if (key) obj[key] = value ?? '';\n    }\n\n    return obj;\n  }\n  /** Aynı “type” için ardışık kayıtları mantıklı gruplara böler */\n\n\n  groupByTypeAsObjects(rows, type) {\n    const filtered = rows.filter(r => r.type === type);\n    const groups = [];\n    let current = null;\n\n    const pushCurrent = () => {\n      if (current && Object.keys(current).length > 0) {\n        groups.push({ ...current\n        });\n      }\n\n      current = null;\n    };\n\n    for (const r of filtered) {\n      if (!current) current = {};\n      const key = r.key ?? '';\n      const val = r.value ?? ''; // Yeni grup başlangıcını sez: aynı key tekrar ediyorsa veya boundary key geldiyse\n\n      const isBoundary = GROUP_BOUNDARY_KEYS.includes(key);\n      const keyExists = key && current[key] !== undefined;\n\n      if (isBoundary && Object.keys(current).length > 0 || keyExists) {\n        pushCurrent();\n        current = {};\n      }\n\n      if (key) current[key] = val;\n    }\n\n    pushCurrent();\n    return groups;\n  }\n  /** Flat satıra Param + Header değerlerini enjekte eder (varsa boşları doldurur) */\n\n\n  mergeParamHeader(row, parameters, headers) {\n    const merged = { ...row\n    };\n\n    for (const {\n      key,\n      value\n    } of [...parameters, ...headers]) {\n      if (!key) continue;\n      const cur = merged[key];\n\n      if (cur === undefined || cur === null || cur === '') {\n        merged[key] = value ?? '-';\n      }\n    }\n\n    return merged;\n  }\n\n  buildPropertyList(base, parameters, headers) {\n    const set = new Set(base);\n\n    for (const {\n      key\n    } of parameters) if (key) set.add(key);\n\n    for (const {\n      key\n    } of headers) if (key) set.add(key);\n\n    return Array.from(set);\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["catchError","firstValueFrom","throwError","timeout","GROUP_BOUNDARY_KEYS","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","csvOptions","xmlText","readFileAsText","csvString","uploadXml","pipe","err","btmResult","transformBtmCsv","processedData","length","baseProps","properties","buildPropertyList","parametersData","headerData","resultRows","map","row","mergeParamHeader","result","prettyJson","via","delimiter","detectDelimiter","defaultOptions","hasHeader","skipEmptyLines","selectedDelimiter","doubleQuoteWrap","selectedRowDelimiter","rowPrefix","rowSuffix","selectedEncoding","selectedQuoteOption","trimWhitespace","options","csvFile","File","type","converterResult","convert","converter","getConverter","Error","localResult","Promise","resolve","reject","reader","FileReader","onload","String","onerror","readAsText","lines","trim","split","slice","candidates","counts","Object","fromEntries","d","line","countDelimiterOutsideQuotes","best","max","c","entries","cnt","inQuotes","i","ch","csv","rows","parseTypeKeyValueCsv","rawRows","extractKeyValue","ibanGroups","groupByTypeAsObjects","detailGroups","tmp","det","finalNo","iban","push","FinalAccountNo","DestinationIban","HesapNo","Iban","TotalCount","OrderDetails","TransferAmount","TotalAmount","ToplamTutar","Toplam","RegisterId","Sicil","SicilNo","RegistrationId","paramObj","toObject","headerObj","ibanObj","totalAmount","registerId","j","g","rawLine","cols","splitCsvLine","key","rest","value","join","replace","out","cur","s","filter","r","pairs","obj","filtered","groups","current","pushCurrent","keys","val","isBoundary","includes","keyExists","undefined","parameters","headers","merged","base","set","Set","add","Array","from","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\JsonConverter-Btm\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { catchError, firstValueFrom, throwError, timeout } from 'rxjs';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { CsvOptions } from './csv-converter.service';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\n\r\n/* ---------------------- Types ---------------------- */\r\n\r\nexport interface OrchestratedResult {\r\n  result: Record<string, string>[];\r\n  properties?: string[];\r\n  prettyJson?: any;\r\n  via: 'btm' | 'local';\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n}\r\n\r\nexport interface BtmTransformResult {\r\n  processedData: Record<string, string>[];\r\n  parametersData: Array<{ key: string; value: string }>;\r\n  headerData: Array<{ key: string; value: string }>;\r\n  rawRows: TypeKeyValueRow[];\r\n}\r\n\r\ntype KnownType = 'Parameters' | 'Header' | 'IbanHesap' | 'Details';\r\n\r\ninterface TypeKeyValueRow {\r\n  type: KnownType | string;\r\n  key: string;\r\n  value: string;\r\n}\r\n\r\n/*  Gruplamada yeni kayıt başlangıcını sezmek için ipucu olabilecek alanlar */\r\nconst GROUP_BOUNDARY_KEYS = ['DestinationIban', 'FinalAccountNo', 'Iban', 'HesapNo', 'OrderDetails'];\r\n\r\n/* ---------------------- Service ---------------------- */\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * 1) BTM'yi dener (CSV string alır)\r\n   * 2) CSV'yi doğrudan CsvFileConverterService'e paslar (fallback)\r\n   * 3) BTM başarısızsa local XML converter'a düşer\r\n   */\r\n  async processXml(file: File, csvOptions?: CsvOptions): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    try {\r\n      // --- 1) BTM denemesi (örnek: 2 sn timeout)\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(2000),\r\n          catchError(err => throwError(() => err))\r\n        )\r\n      );\r\n\r\n      const btmResult = this.transformBtmCsv(csvString);\r\n\r\n      if (btmResult.processedData.length > 0) {\r\n        // Flat tablo kolonları: temel alanlar + Param/Header anahtarları\r\n        const baseProps = [\r\n          'DestinationIban', 'FinalAccountNo', 'TotalCount', 'OrderDetails',\r\n          'TransferAmount', 'TotalAmount', 'RegisterId'\r\n        ];\r\n\r\n        const properties = this.buildPropertyList(baseProps, btmResult.parametersData, btmResult.headerData);\r\n\r\n        // Flat satırlara Parameters & Header değerlerini enjekte et\r\n        const resultRows = btmResult.processedData.map(row =>\r\n          this.mergeParamHeader(row, btmResult.parametersData, btmResult.headerData)\r\n        );\r\n\r\n        return {\r\n          result: resultRows,\r\n          properties,\r\n          prettyJson: btmResult,   // tüm ham/ara veriyi görmen için\r\n          via: 'btm',\r\n          parametersData: btmResult.parametersData,\r\n          headerData: btmResult.headerData\r\n        };\r\n      }\r\n\r\n      // --- 1.b) BTM CSV’yi genel CSV dönüştürücüne pasla (header’sız kabul et)\r\n      const delimiter = this.detectDelimiter(csvString);\r\n      const defaultOptions: CsvOptions = {\r\n        hasHeader: false,\r\n        skipEmptyLines: true,\r\n        selectedDelimiter: delimiter,\r\n        doubleQuoteWrap: false,\r\n        selectedRowDelimiter: 'newline',\r\n        rowPrefix: '',\r\n        rowSuffix: '',\r\n        selectedEncoding: 'utf-8',\r\n        selectedQuoteOption: 'none',\r\n        trimWhitespace: true\r\n      };\r\n      const options: CsvOptions = { ...(csvOptions ?? defaultOptions), selectedDelimiter: delimiter };\r\n      const csvFile = new File([csvString], 'btm.csv', { type: 'text/csv' });\r\n      const converterResult = await this.csvFileConverter.convert(csvFile, options);\r\n\r\n      return {\r\n        result: converterResult.result,\r\n        properties: converterResult.properties,\r\n        prettyJson: converterResult.result,\r\n        via: 'btm',\r\n        parametersData: [],\r\n        headerData: []\r\n      };\r\n\r\n    } catch {\r\n      // --- 2) Local XML converter’a düş\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) {\r\n        throw new Error('XML dönüştürücü bulunamadı (local).');\r\n      }\r\n\r\n      const localResult = await converter.convert(file, {});\r\n\r\n      return {\r\n        result: localResult.result,\r\n        properties: localResult.properties,\r\n        prettyJson: localResult.result,\r\n        via: 'local',\r\n        parametersData: [],\r\n        headerData: []\r\n      };\r\n    }\r\n  }\r\n\r\n  /* ---------------------- Helpers ---------------------- */\r\n\r\n  private async readFileAsText(file: File): Promise<string> {\r\n    return new Promise<string>((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(String(reader.result ?? ''));\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /** Basit delimiter tespiti (tırnak içindeki ayraçları dikkate alır) */\r\n  private detectDelimiter(csvString: string): string {\r\n    const lines = csvString.trim().split(/\\r?\\n/).slice(0, 5);\r\n    const candidates = [',', ';', '\\t', '|'] as const;\r\n    const counts: Record<string, number> = Object.fromEntries(candidates.map(d => [d, 0]));\r\n\r\n    for (const line of lines) {\r\n      for (const d of candidates) {\r\n        counts[d] += this.countDelimiterOutsideQuotes(line, d);\r\n      }\r\n    }\r\n\r\n    let best = ',';\r\n    let max = -1;\r\n    for (const [d, c] of Object.entries(counts)) {\r\n      if (c > max) { max = c; best = d; }\r\n    }\r\n    return best;\r\n  }\r\n\r\n  private countDelimiterOutsideQuotes(line: string, delimiter: string): number {\r\n    let cnt = 0, inQuotes = false;\r\n    for (let i = 0; i < line.length; i++) {\r\n      const ch = line[i];\r\n      if (ch === '\"') inQuotes = !inQuotes;\r\n      else if (!inQuotes && ch === delimiter) cnt++;\r\n    }\r\n    return cnt;\r\n  }\r\n\r\n  /* ---------------------- BTM CSV -> JSON ---------------------- */\r\n\r\n  private transformBtmCsv(csv: string): BtmTransformResult {\r\n    const rows = this.parseTypeKeyValueCsv(csv);\r\n\r\n    if (rows.length === 0) {\r\n      return { processedData: [], parametersData: [], headerData: [], rawRows: [] };\r\n    }\r\n\r\n    // Parameters / Header koleksiyonları\r\n    const parametersData = this.extractKeyValue(rows, 'Parameters');\r\n    const headerData     = this.extractKeyValue(rows, 'Header');\r\n\r\n    // Gruplar\r\n    let ibanGroups   = this.groupByTypeAsObjects(rows, 'IbanHesap');\r\n    let detailGroups = this.groupByTypeAsObjects(rows, 'Details');\r\n\r\n    // IbanHesap yoksa Details’ten alan üret\r\n    if (ibanGroups.length === 0 && detailGroups.length > 0) {\r\n      const tmp: Record<string, string>[] = [];\r\n      for (const det of detailGroups) {\r\n        const finalNo = det['FinalAccountNo'] || det['HesapNo'] || '';\r\n        const iban    = det['DestinationIban'] || det['Iban'] || '';\r\n        if (finalNo || iban) {\r\n          tmp.push({ FinalAccountNo: finalNo, DestinationIban: iban, HesapNo: finalNo, Iban: iban });\r\n        }\r\n      }\r\n      if (tmp.length > 0) ibanGroups = tmp;\r\n    }\r\n\r\n    // Details yoksa ama IbanHesap varsa boş iskelet üret\r\n    if (detailGroups.length === 0 && ibanGroups.length > 0) {\r\n      detailGroups = ibanGroups.map(() => ({\r\n        TotalCount: '', OrderDetails: '', TransferAmount: '',\r\n        TotalAmount: '', ToplamTutar: '', Toplam: '',\r\n        RegisterId: '', Sicil: '', SicilNo: '', RegistrationId: ''\r\n      }));\r\n    }\r\n\r\n    // Param/Header objeleri (eksik alanları tamamlamak için)\r\n    const paramObj  = this.toObject(parametersData);\r\n    const headerObj = this.toObject(headerData);\r\n\r\n    // UI tablosu için nihai satırlar\r\n    const processedData = ibanGroups.map((ibanObj, i) => {\r\n      const det = detailGroups[i] ?? {};\r\n\r\n      let totalAmount = det['TotalAmount'] || det['ToplamTutar'] || det['Toplam'] || '';\r\n      let registerId  = det['RegisterId'] || det['Sicil'] || det['SicilNo'] || det['RegistrationId'] || '';\r\n\r\n      // Eksikse diğer detail gruplarında ara\r\n      if (!totalAmount || !registerId) {\r\n        for (let j = 0; j < detailGroups.length; j++) {\r\n          const g = detailGroups[j] ?? {};\r\n          if (!totalAmount) totalAmount = g['TotalAmount'] || g['ToplamTutar'] || g['Toplam'] || '';\r\n          if (!registerId && j === i) registerId = g['RegisterId'] || g['Sicil'] || g['SicilNo'] || g['RegistrationId'] || '';\r\n        }\r\n        if (!registerId) {\r\n          for (const g of detailGroups) {\r\n            registerId = g['RegisterId'] || g['Sicil'] || g['SicilNo'] || g['RegistrationId'] || '';\r\n            if (registerId) break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Hâlâ eksikse Param/Header’dan tamamla\r\n      if (!totalAmount) totalAmount = paramObj['TotalAmount'] || headerObj['TotalAmount'] || '';\r\n      if (!registerId)  registerId  = paramObj['RegisterId'] || headerObj['RegisterId'] || paramObj['Sicil'] || headerObj['Sicil'] || '';\r\n\r\n      return {\r\n        DestinationIban: ibanObj['DestinationIban'] || ibanObj['Iban'] || '',\r\n        FinalAccountNo:  ibanObj['FinalAccountNo']  || ibanObj['HesapNo'] || '',\r\n        TotalCount:      det['TotalCount'] || '',\r\n        OrderDetails:    det['OrderDetails'] || det['Detail'] || '',\r\n        TransferAmount:  det['TransferAmount'] || det['Miktar'] || '',\r\n        TotalAmount:     totalAmount || '---',\r\n        RegisterId:      registerId || '---'\r\n      };\r\n    });\r\n\r\n    return { processedData, parametersData, headerData, rawRows: rows };\r\n  }\r\n\r\n  /** “Type,Key,Value” formatındaki CSV’yi güvenli ayrıştırır */\r\n  private parseTypeKeyValueCsv(csv: string): TypeKeyValueRow[] {\r\n    const lines = csv.trim().split(/\\r?\\n/);\r\n    if (lines.length === 0) return [];\r\n\r\n    // Ayraç tespiti (satırların kendisine göre)\r\n    const delimiter = this.detectDelimiter(csv);\r\n\r\n    const rows: TypeKeyValueRow[] = [];\r\n    for (const rawLine of lines) {\r\n      const line = rawLine.trim();\r\n      if (!line) continue;\r\n\r\n      const cols = this.splitCsvLine(line, delimiter);\r\n      if (cols.length < 3) continue;\r\n\r\n      const [type, key, ...rest] = cols;\r\n      const value = rest.join(delimiter).trim();\r\n\r\n      rows.push({\r\n        type: (type as KnownType) ?? String(type),\r\n        key: key ?? '',\r\n        value: value.replace(/^\"|\"$/g, '') // dış tırnakları soy\r\n      });\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  /** Tırnaklı alanları doğru parçalayarak satırı ayırır */\r\n  private splitCsvLine(line: string, delimiter: string): string[] {\r\n    const out: string[] = [];\r\n    let cur = '';\r\n    let inQuotes = false;\r\n\r\n    for (let i = 0; i < line.length; i++) {\r\n      const ch = line[i];\r\n\r\n      if (ch === '\"') {\r\n        // Çift tırnak kaçışı: \"\" -> \"\r\n        if (inQuotes && line[i + 1] === '\"') {\r\n          cur += '\"';\r\n          i++;\r\n        } else {\r\n          inQuotes = !inQuotes;\r\n        }\r\n      } else if (ch === delimiter && !inQuotes) {\r\n        out.push(cur);\r\n        cur = '';\r\n      } else {\r\n        cur += ch;\r\n      }\r\n    }\r\n    out.push(cur);\r\n    return out.map(s => s.trim());\r\n  }\r\n\r\n  private extractKeyValue(rows: TypeKeyValueRow[], type: KnownType): Array<{ key: string; value: string }> {\r\n    return rows\r\n      .filter(r => r.type === type)\r\n      .map(r => ({ key: r.key ?? '', value: r.value ?? '' }));\r\n  }\r\n\r\n  private toObject(pairs: Array<{ key: string; value: string }>): Record<string, string> {\r\n    const obj: Record<string, string> = {};\r\n    for (const { key, value } of pairs) {\r\n      if (key) obj[key] = value ?? '';\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  /** Aynı “type” için ardışık kayıtları mantıklı gruplara böler */\r\n  private groupByTypeAsObjects(rows: TypeKeyValueRow[], type: KnownType): Array<Record<string, string>> {\r\n    const filtered = rows.filter(r => r.type === type);\r\n    const groups: Array<Record<string, string>> = [];\r\n\r\n    let current: Record<string, string> | null = null;\r\n\r\n    const pushCurrent = () => {\r\n      if (current && Object.keys(current).length > 0) {\r\n        groups.push({ ...current });\r\n      }\r\n      current = null;\r\n    };\r\n\r\n    for (const r of filtered) {\r\n      if (!current) current = {};\r\n\r\n      const key = r.key ?? '';\r\n      const val = r.value ?? '';\r\n\r\n      // Yeni grup başlangıcını sez: aynı key tekrar ediyorsa veya boundary key geldiyse\r\n      const isBoundary = GROUP_BOUNDARY_KEYS.includes(key);\r\n      const keyExists = key && current[key] !== undefined;\r\n\r\n      if ((isBoundary && Object.keys(current).length > 0) || keyExists) {\r\n        pushCurrent();\r\n        current = {};\r\n      }\r\n\r\n      if (key) current[key] = val;\r\n    }\r\n\r\n    pushCurrent();\r\n    return groups;\r\n  }\r\n\r\n  /** Flat satıra Param + Header değerlerini enjekte eder (varsa boşları doldurur) */\r\n  private mergeParamHeader(\r\n    row: Record<string, string>,\r\n    parameters: Array<{ key: string; value: string }>,\r\n    headers: Array<{ key: string; value: string }>\r\n  ): Record<string, string> {\r\n    const merged: Record<string, string> = { ...row };\r\n\r\n    for (const { key, value } of [...parameters, ...headers]) {\r\n      if (!key) continue;\r\n      const cur = merged[key];\r\n      if (cur === undefined || cur === null || cur === '') {\r\n        merged[key] = value ?? '-';\r\n      }\r\n    }\r\n    return merged;\r\n  }\r\n\r\n  private buildPropertyList(\r\n    base: string[],\r\n    parameters: Array<{ key: string; value: string }>,\r\n    headers: Array<{ key: string; value: string }>\r\n  ): string[] {\r\n    const set = new Set<string>(base);\r\n    for (const { key } of parameters) if (key) set.add(key);\r\n    for (const { key } of headers) if (key) set.add(key);\r\n    return Array.from(set);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}