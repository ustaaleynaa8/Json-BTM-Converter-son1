{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ustaa/Desktop/json-convert-with-btm-backendfull2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, throwError } from 'rxjs';\nimport { timeout, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./xml-btm.service\";\nimport * as i2 from \"./file-converter.service\";\nimport * as i3 from \"./csv-file-converter.service\";\nexport class BtmOrchestratorService {\n  constructor(xmlBtm, fileConverter, csvFileConverter) {\n    this.xmlBtm = xmlBtm;\n    this.fileConverter = fileConverter;\n    this.csvFileConverter = csvFileConverter;\n  }\n  /**\r\n   * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n   * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n   */\n\n\n  processXml(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const xmlText = yield _this.readFileAsText(file); // 1) BTM'yi dene (2 sn timeout)\n\n      try {\n        const csvString = yield firstValueFrom(_this.xmlBtm.uploadXml(xmlText).pipe(timeout(2000), catchError(err => throwError(() => err))));\n        console.log('BTM CSV çıktısı:', csvString); // --- BTM'den gelen veriyi güvenli parse et ---\n\n        const lines = csvString?.trim() ? csvString.trim().split(/\\r?\\n/) : [];\n        const baseMeta = {}; // Parameters + Headers\n\n        const records = []; // Sonuç satırları\n\n        let current = null;\n\n        const startNewDetail = () => {\n          // sadece meta’yı kopyala; önceki detail alanları bulaşmasın\n          current = { ...baseMeta\n          };\n        };\n\n        for (const raw of lines) {\n          if (!raw?.trim()) continue;\n\n          const parts = _this.parseCsvLine(raw); // [Type, Key, Value]\n\n\n          const _typeRaw = (parts[0] ?? '').trim();\n\n          const key = (parts[1] ?? '').trim(); // Value içinde virgül olabilir; kalan tüm parçaları geri birleştiriyoruz\n\n          const value = parts.slice(2).join(',').trim();\n          if (!_typeRaw || !key) continue;\n\n          const _type = _typeRaw.toLowerCase(); // 1) Parameters/Headers => meta\n\n\n          if (_type === 'parameters' || _type === 'header' || _type === 'headers') {\n            baseMeta[key] = value; // aktif kayıt varsa aynı meta değişikliğini o kayda da yansıtmak istersen uncomment edebilirsin:\n            // if (current) current[key] = value;\n\n            continue;\n          } // 2) Details => satırlar\n\n\n          if (_type === 'details') {\n            // yeni kayıt sınırı: RegisterId geldiğinde önceki kaydı flush et\n            if (key.toLowerCase() === 'registerid') {\n              if (current && Object.keys(current).length > 0 && current['RegisterId'] !== undefined) {\n                records.push({ ...current\n                });\n                current = null;\n              }\n\n              if (!current) startNewDetail();\n              current['RegisterId'] = value;\n              continue;\n            }\n\n            if (!current) startNewDetail();\n            current[key] = value;\n            continue;\n          } // Beklenmeyen Type: sessizce geç\n\n        } // son kaydı da ekle\n\n\n        if (current && Object.keys(current).length > 0 && current['RegisterId'] !== undefined) {\n          records.push({ ...current\n          });\n        }\n\n        console.log('BTM tüm kayıtlar:', records);\n        const rows = records;\n        const properties = Array.from(new Set(rows.flatMap(o => Object.keys(o))));\n        const pretty = rows; // istersen burada gruplu görünüm üretebilirsin\n\n        return {\n          result: rows,\n          properties,\n          prettyJson: pretty,\n          via: 'btm'\n        };\n      } catch (_btmErr) {\n        // 2) BTM başarısızsa local converter'a düş\n        const converter = _this.fileConverter.getConverter('xml');\n\n        if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\n        const localResult = yield converter.convert(file, {// UI'dan opsiyon geliyorsa burada parametrik verebilirsin\n        }); // localResult zaten { result, properties } şemasında\n\n        return { ...localResult,\n          via: 'local'\n        };\n      }\n    })();\n  } // --------- Helpers ---------\n\n\n  readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = () => resolve(reader.result);\n\n      reader.onerror = err => reject(err);\n\n      reader.readAsText(file);\n    });\n  }\n  /**\r\n   * Tırnaklı CSV satırını güvenli parse eder (virgül içeriyorsa bozulmaz).\r\n   * Örn: Parameters,\"Some, Key\",\"Value, with, commas\"\r\n   */\n\n\n  parseCsvLine(line) {\n    const out = [];\n    let cur = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n\n      if (ch === '\"') {\n        // kaçışlı çift tırnak (\"\") -> tek tırnak olarak al\n        if (inQuotes && line[i + 1] === '\"') {\n          cur += '\"';\n          i++;\n        } else {\n          inQuotes = !inQuotes;\n        }\n      } else if (ch === ',' && !inQuotes) {\n        out.push(cur.trim());\n        cur = '';\n      } else {\n        cur += ch;\n      }\n    }\n\n    out.push(cur.trim());\n    return out;\n  } // Eski {Type,Key,Value} dizisini düz objeye çeviren yardımcı (gerekirse kullan)\n\n\n  transformBtmJson(flatData) {\n    const result = {};\n\n    for (const row of flatData || []) {\n      const {\n        Key,\n        Value\n      } = row || {};\n      if (Key && Value !== undefined) result[Key] = Value;\n    }\n\n    return result;\n  }\n\n}\n\nBtmOrchestratorService.ɵfac = function BtmOrchestratorService_Factory(t) {\n  return new (t || BtmOrchestratorService)(i0.ɵɵinject(i1.XmlBtmService), i0.ɵɵinject(i2.FileConverterService), i0.ɵɵinject(i3.CsvFileConverterService));\n};\n\nBtmOrchestratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: BtmOrchestratorService,\n  factory: BtmOrchestratorService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["firstValueFrom","throwError","timeout","catchError","BtmOrchestratorService","constructor","xmlBtm","fileConverter","csvFileConverter","processXml","file","xmlText","readFileAsText","csvString","uploadXml","pipe","err","console","log","lines","trim","split","baseMeta","records","current","startNewDetail","raw","parts","parseCsvLine","_typeRaw","key","value","slice","join","_type","toLowerCase","Object","keys","length","undefined","push","rows","properties","Array","from","Set","flatMap","o","pretty","result","prettyJson","via","_btmErr","converter","getConverter","Error","localResult","convert","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","line","out","cur","inQuotes","i","ch","transformBtmJson","flatData","row","Key","Value","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\ustaa\\Desktop\\json-convert-with-btm-backendfull2\\src\\app\\services\\btm-orchestrator.service.ts"],"sourcesContent":["// src/app/services/btm-orchestrator.service.ts\r\nimport { Injectable } from '@angular/core';\r\nimport { XmlBtmService } from './xml-btm.service';\r\nimport { FileConverterService } from './file-converter.service';\r\nimport { CsvFileConverterService } from './csv-file-converter.service';\r\nimport { firstValueFrom, throwError } from 'rxjs';\r\nimport { timeout, catchError } from 'rxjs/operators';\r\n\r\nexport interface OrchestratedResult {\r\n  result: any[];         // flat tablo datası\r\n  properties: string[];  // tablo başlıkları\r\n  prettyJson?: any;      // okunaklı/gruplu JSON (BTM başarılıysa)\r\n  via: 'btm' | 'local';  // hangi yol kullanıldı\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BtmOrchestratorService {\r\n  constructor(\r\n    private xmlBtm: XmlBtmService,\r\n    private fileConverter: FileConverterService,\r\n    private csvFileConverter: CsvFileConverterService\r\n  ) {}\r\n\r\n  /**\r\n   * Tek sorumluluk: XML dosyasını al, BTM'yi dene, olmazsa local parser'a düş,\r\n   * sonucu tablo (flat) + opsiyonel prettyJson ile döndür.\r\n   */\r\n  async processXml(file: File): Promise<OrchestratedResult> {\r\n    const xmlText = await this.readFileAsText(file);\r\n\r\n    // 1) BTM'yi dene (2 sn timeout)\r\n    try {\r\n      const csvString: string = await firstValueFrom(\r\n        this.xmlBtm.uploadXml(xmlText).pipe(\r\n          timeout(2000),\r\n          catchError(err => throwError(() => err))\r\n        )\r\n      );\r\n\r\n      console.log('BTM CSV çıktısı:', csvString);\r\n\r\n      // --- BTM'den gelen veriyi güvenli parse et ---\r\n      const lines = csvString?.trim() ? csvString.trim().split(/\\r?\\n/) : [];\r\n      const baseMeta: Record<string, any> = {};        // Parameters + Headers\r\n      const records: Array<Record<string, any>> = [];  // Sonuç satırları\r\n\r\n      let current: Record<string, any> | null = null;\r\n\r\n      const startNewDetail = () => {\r\n        // sadece meta’yı kopyala; önceki detail alanları bulaşmasın\r\n        current = { ...baseMeta };\r\n      };\r\n\r\n      for (const raw of lines) {\r\n        if (!raw?.trim()) continue;\r\n\r\n        const parts = this.parseCsvLine(raw); // [Type, Key, Value]\r\n        const _typeRaw = (parts[0] ?? '').trim();\r\n        const key = (parts[1] ?? '').trim();\r\n        // Value içinde virgül olabilir; kalan tüm parçaları geri birleştiriyoruz\r\n        const value = parts.slice(2).join(',').trim();\r\n\r\n        if (!_typeRaw || !key) continue;\r\n        const _type = _typeRaw.toLowerCase();\r\n\r\n        // 1) Parameters/Headers => meta\r\n        if (_type === 'parameters' || _type === 'header' || _type === 'headers') {\r\n          baseMeta[key] = value;\r\n          // aktif kayıt varsa aynı meta değişikliğini o kayda da yansıtmak istersen uncomment edebilirsin:\r\n          // if (current) current[key] = value;\r\n          continue;\r\n        }\r\n\r\n        // 2) Details => satırlar\r\n        if (_type === 'details') {\r\n          // yeni kayıt sınırı: RegisterId geldiğinde önceki kaydı flush et\r\n          if (key.toLowerCase() === 'registerid') {\r\n            if (current && Object.keys(current).length > 0 && current['RegisterId'] !== undefined) {\r\n              records.push({ ...current });\r\n              current = null;\r\n            }\r\n            if (!current) startNewDetail();\r\n            current!['RegisterId'] = value;\r\n            continue;\r\n          }\r\n\r\n          if (!current) startNewDetail();\r\n          current![key] = value;\r\n          continue;\r\n        }\r\n\r\n        // Beklenmeyen Type: sessizce geç\r\n      }\r\n\r\n      // son kaydı da ekle\r\n      if (current && Object.keys(current).length > 0 && current['RegisterId'] !== undefined) {\r\n        records.push({ ...current });\r\n      }\r\n\r\n      console.log('BTM tüm kayıtlar:', records);\r\n\r\n      const rows = records;\r\n      const properties = Array.from(new Set(rows.flatMap(o => Object.keys(o))));\r\n      const pretty = rows; // istersen burada gruplu görünüm üretebilirsin\r\n\r\n      return { result: rows, properties, prettyJson: pretty, via: 'btm' };\r\n    } catch (_btmErr) {\r\n      // 2) BTM başarısızsa local converter'a düş\r\n      const converter = this.fileConverter.getConverter('xml');\r\n      if (!converter) throw new Error('XML dönüştürücü bulunamadı (local).');\r\n\r\n      const localResult = await converter.convert(file, {\r\n        // UI'dan opsiyon geliyorsa burada parametrik verebilirsin\r\n      });\r\n\r\n      // localResult zaten { result, properties } şemasında\r\n      return { ...localResult, via: 'local' };\r\n    }\r\n  }\r\n\r\n  // --------- Helpers ---------\r\n\r\n  private readFileAsText(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = (err) => reject(err);\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Tırnaklı CSV satırını güvenli parse eder (virgül içeriyorsa bozulmaz).\r\n   * Örn: Parameters,\"Some, Key\",\"Value, with, commas\"\r\n   */\r\n  private parseCsvLine(line: string): string[] {\r\n    const out: string[] = [];\r\n    let cur = '';\r\n    let inQuotes = false;\r\n\r\n    for (let i = 0; i < line.length; i++) {\r\n      const ch = line[i];\r\n      if (ch === '\"') {\r\n        // kaçışlı çift tırnak (\"\") -> tek tırnak olarak al\r\n        if (inQuotes && line[i + 1] === '\"') {\r\n          cur += '\"';\r\n          i++;\r\n        } else {\r\n          inQuotes = !inQuotes;\r\n        }\r\n      } else if (ch === ',' && !inQuotes) {\r\n        out.push(cur.trim());\r\n        cur = '';\r\n      } else {\r\n        cur += ch;\r\n      }\r\n    }\r\n    out.push(cur.trim());\r\n    return out;\r\n  }\r\n\r\n  // Eski {Type,Key,Value} dizisini düz objeye çeviren yardımcı (gerekirse kullan)\r\n  private transformBtmJson(flatData: Array<{ Type: string; Key: string; Value: string }>) {\r\n    const result: any = {};\r\n    for (const row of flatData || []) {\r\n      const { Key, Value } = row || ({} as any);\r\n      if (Key && Value !== undefined) result[Key] = Value;\r\n    }\r\n    return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}